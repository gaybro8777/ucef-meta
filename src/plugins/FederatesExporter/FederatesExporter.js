/*

Comment from PluginGenerator
--------------------------------------------
Template for file Generated by PluginGenerator 0.14.0 from webgme
on Wed Dec 02 2015 15:05:52 GMT-0600 (CST). 
--------------------------------------------

File completed by unknown programmer (probably H. Neema)

File modified extensively by T. Kramer 

File reformatted in C style, as far as possible.

In this file, the functions defined in the "define" arguments are
executed by calls such as, for example, PubSubVisitors.call(this),
which in a sane language would be written as this.call(PubSubVisitors).

A separate XML file is generated for each Federate in a project.

federateInfos
-------------

The federateInfos object collects information for each
federate. federateInfos uses federate ids as property names and has
the form

{federateId1: value1, federateId2: value2, ...}. 

The value corresponding to a federateId is an object of the form
{name: federateName,
 directory: directoryPath,
 pubSubObjects:
  {objectId1: objectData1, objectId2: objectData2, ...},
 pubSubInteractions:
  {interactId1: interactData1, interactId2: interactData2, ...}}

The directory property is not used in the FederatesExporter but is used
elsewhere.

The interactData values have the form:

{publish: n, subscribe: m} where n and m are each either 1 or 0,
meaning yes and no. The interactData values are used in an obvious way in
interactionTraverserXml to set the sharingXml of the interaction to
one of Publish, Subscribe, PublishSubscribe, or Neither.

The objectData values have the form:

{publish: n, mayPublish: p, subscribe: m, maySubscribe: q}
where n, m, p and q are each either 1 or 0, meaning yes and no.
publish means definitely publish. mayPublish means maybe publish.
Similarly for subscribe.

The objectData values are used in objectTraverserXml to set the
sharingXml of the object to one of Publish, Subscribe,
PublishSubscribe, or Neither.

For publishing, an object should Publish if either (1) it has a
publish relation with the federate (call that a type P object) or (2)
it is an ancestor of such an object (call that a type Q object) and
has an own attribute. If an object is both, it is treated like a
P. For a type P object, publish and mayPublish are both set to 1 when
the publish relation is examined. For a type Q object, publish is
always 0, but mayPublish will be set to 1 in objectTraverserCheck if
any descendant has mayPublish set to 1.

For subscribing, the situation is exactly analogous to publishing.

Notice that pubSubInteractions and pubSubObjects of a federate have
the same name and same structure as the pubSubInteractions and
pubSubObjects of the deployment exporter. This enables using the six
visit_XXX functions in PubSubVisitors.js for both exporters. 

The value in federateInfos for a federateId is initialized where
the federate is first encountered. That may be in either:

(1) the atModelNode function defined in C2Core/ModelTraverserMixin.js.
If initialized here, the pubSubObjects and pubSubInteractions are both
empty objects. If a federateInfo for a federate has already been created
when the federate is encountered in this function, the name of the
federate is added to the data (since it will be missing).

(2) one of the visit_StaticXXX functions defined in PubSubVisitors.js.
If initialized here, (i) some data will be put into either the
pubSubObjects or the pubSubInteractions and (ii) the federate name
will be set to null since it is not available. If a federateInfo for a
federate has already been created when the federate is encountered in
a visit_StaticXXX function, some data will be put into either the
pubSubObjects or the pubSubInteractions.

See the documentation of objectTraverserCheck and
interactionTraverserCheck regarding how additional items are added to
pubSubInteractions and pubSubObjects.

The pubSubInteractions and pubSubObjects of a federate are used in the
objectTraverserXml and interactionTraverserXml functions to set the
values for sharing that are put into the output XML file for the
federate.

endJoinResigns
--------------

The endJoinResigns object uses interaction ids as property names; the
value corresponding to a name is a pointer to the interaction. The
endJoinResigns are built in the visit_Interaction function of
RTIVisitors.js (where the required information is available). The
interactions put into endJoinResigns are those whose name is one of:
SimEnd, FederateJoinInteraction, FederateResignInteraction. The
endJoinResigns are used in the fomGenerator function to add those
interactions to those to be be included in an XML fom file for a
federate. The publish and subscribe values for interactions in the
endJoinResigns are set in the addEndJoinResign function.

*/

define
([
  'text!./metadata.json',
  'plugin/PluginBase',
  'common/util/ejs',
  'C2Core/ModelTraverserMixin',
  'C2Core/xmljsonconverter',
  'C2Core/MavenPOM',
  'FederatesExporter/PubSubVisitors',
  'FederatesExporter/RTIVisitors',
  'FederatesExporter/Templates/Templates',
  'C2Federates/GenericFederate',
  'C2Federates/JavaFederate',
  'C2Federates/MapperFederate',
  'C2Federates/CppFederate',
  'C2Federates/OmnetFederate',
  'C2Federates/CPNFederate',
  'C2Federates/GridLabDFederate',
  'C2Federates/LabVIEWFederate'],
 function (pluginMetadata,
           PluginBase,
           ejs,
           ModelTraverserMixin,
           JSON2XMLConverter,
           MavenPOM,
           PubSubVisitors,
           RTIVisitors,
           TEMPLATES,
           GenericFederate,
           JavaFederate,
           MapperFederate,
           CppFederate,
           OmnetFederate,
           CPNFederate,
           GridLabDFederate,
           LabVIEWFederate)
 {
    'use strict';
    var FederatesExporter;          // function variable
    var addEndJoinResign;           // function variable
    var objectTraverserCheck;       // function variable
    var objectTraverserXml;         // function variable
    var interactionTraverserCheck;  // function variable
    var interactionTraverserXml;    // function variable
    var fomGenerator;               // function variable
    
    pluginMetadata = JSON.parse(pluginMetadata);
     
/***********************************************************************/

/* FederatesExporter (function-valued variable of top-level function object)

*/

    FederatesExporter = function()
    {
      this.federateTypes = this.federateTypes || {};
      this.federateInfos = {}; // see documentation above
      this.endJoinResigns = {};  // see documentation above
      PluginBase.call(this);
      ModelTraverserMixin.call(this);
      PubSubVisitors.call(this);
      RTIVisitors.call(this);
      GenericFederate.call(this);
      JavaFederate.call(this);
      MapperFederate.call(this);
      CppFederate.call(this);
      OmnetFederate.call(this);
      CPNFederate.call(this);
      GridLabDFederate.call(this);
      LabVIEWFederate.call(this);      
      
      this.mainPom = new MavenPOM();
      this._jsonToXml = new JSON2XMLConverter.Json2xml();
      this.pluginMetadata = pluginMetadata;
    };
   
/***********************************************************************/

    // Prototypal inheritance from PluginBase.
    FederatesExporter.prototype = Object.create(PluginBase.prototype);
    FederatesExporter.prototype.constructor = FederatesExporter;
    FederatesExporter.metadata = pluginMetadata;
    
/***********************************************************************/

/*  addEndJoinResign (function-valued variable of top-level function object)

Returned Value: none

Called By: fomGenerator

This adds an entry to the pubSubInteractions for any interaction named
SimEnd, FederateResignInteraction, or FederateJoinInteraction.

*/
    addEndJoinResign = function( /* ARGUMENTS                               */
     name,                       /* (string) name of the interaction to add */
     pubSubInteractions,         /* (object) interaction data to add to     */
     id)                         /* (string) id of the interation to add    */
    {
      if (name == 'SimEnd')
        {
          if (pubSubInteractions[id])
            {
              pubSubInteractions[id].subscribe = 1;
            }
          else
            {
              pubSubInteractions[id] = {publish: 0,
                                        subscribe: 1};
            }
        }
      else if ((name == 'FederateResignInteraction') ||
               (name == 'FederateJoinInteraction'))
        {
          if (pubSubInteractions[id])
            {
              pubSubInteractions[id].publish = 1;
            }
          else
            {
              pubSubInteractions[id] = {publish: 1,
                                        subscribe: 0};
            }
        }
    };

/***********************************************************************/

/* objectTraverserCheck (function-valued variable of top-level function object)

Returned Value: none

Called By:
  anonyomous fom generator in FederatesExporter.prototype.main
  objectTraverserCheck (recursively)

This adds entries to the pubSubObjects of a federate for all ancestors
of objects that already have entries.

By calling itself recursively, this goes through the object tree (from
top down) but builds the pubSubObjects of the federate from bottom up.
 
For each object that has an entry in the federate.pubSubObjects:

  If the parent already has an entry in the federate.pubSubObjects:
    If object has non-zero mayPublish, the parent's mayPublish is set to 1.
    If object has non-zero maySubscribe, the parent's maySubscribe is set to 1.

  Otherwise, a new entry for parent is put into the federate.pubSubObjects
  with publish set to 0, subscribe set to 0, mayPublish set to the object's
  mayPublish and maySubscribe set to the object's maySubscribe.

If the parent publishes or subscribes to the federate, an entry in
federate.pubSubObjects for the parent will have been made previously
in PubSubVisitors.

The final effect is that any object that is an ancestor of any object
originally put on the federate.pubSubObjects in PubSubVisitors is also
on federate.pubSubObjects, with its publish, subscribe, mayPublish, and
maySubscribe values set appropriately.

*/

    objectTraverserCheck = function( /* ARGUMENTS                     */
     federate,                       /* (object) federate of interest */
     object)                         /* (object) object to process    */
    {
      var objectPubSub;
      var parentPubSub;
      
      object.children.forEach(function(child)
      {
        objectTraverserCheck(federate, child);
      });
      if (object.name != 'ObjectRoot' &&
          (object.id in federate.pubSubObjects))
        {
          objectPubSub = federate.pubSubObjects[object.id];
          if (object.basePath in federate.pubSubObjects)
            {
              parentPubSub = federate.pubSubObjects[object.basePath];
              if (objectPubSub.mayPublish)
                {
                  parentPubSub.mayPublish = 1;
                }
              if (objectPubSub.maySubscribe)
                {
                  parentPubSub.maySubscribe = 1;
                }
            }
          else
            {
              federate.pubSubObjects[object.basePath] =
                {publish: 0,
                 subscribe: 0,
                 mayPublish: objectPubSub.mayPublish,
                 maySubscribe: objectPubSub.maySubscribe};
            }
        }
    };

/***********************************************************************/

/* objectTraverserXml (function-valued variable of top-level function object)

Returned Value: a string of XML representing the object and its descendants

Called By:
  anonyomous fom generator in FederatesExporter.prototype.main
  objectTraverserXml (recursively)

objectTraverserXml is a recursive function that builds the XML for
objects in a federate.

The function takes information about a federate and takes an object
that may have children (also objects).

The function begins by creating an objModel. The objModel is given the
same name and attributes as the object and is given children that are
XML code built by a recursive call to the function on the children of
the object.  Information for printing XML is added to the data for
each attribute of the object. Sharing data for the XML is derived from
the federate information and the attribute data.

Then XML for the objModel is generated from the objModel (and saved)
by calling ejs.render using the fedfile_simobject_xml XML Template.

*/
      
    objectTraverserXml = function( /* ARGUMENTS                     */
     federate,                     /* (object) federate of interest */
     object,                       /* (object) object to process    */
     space)                        /* (string) indentation space    */
    {
      var objModel;
      var objPuBSub;
      var hasOwn;

      objModel = {name: object.name,
                  sharingXml: 0,
                  indent: space,
                  attributes: object.attributes,
                  children: []};
      hasOwn = 0;
      // The attributes in the objModel are the attributes of the object.
      // Properites of attributes not related to XML generation are not
      // modified, but properties of attributes related to XML generation
      // are assigned as follows.
      objModel.attributes.forEach(function(attr)
      {
        attr.deliveryXml = ((attr.delivery === "reliable") ? "HLAreliable" :
                            "HLAbestEffort");
        attr.orderXml = ((attr.order === "timestamp") ? "TimeStamp" :
                         "Receive");
        if (!attr.inherited)
          {
            hasOwn = 1;
          }
      });
      // An object should publish if either (1) the data for it in the
      // federate information says publish or (2) the data says maybe
      // publish and one or more of the object's attributes is an own
      // attribute. Similarly for subscribing.
      objPuBSub = federate.pubSubObjects[object.id];
      if (objPuBSub && (objPuBSub.publish ||
                        (objPuBSub.mayPublish && hasOwn)))
        {
          if (objPuBSub.subscribe || objPuBSub.maySubscribe)
            {
              objModel.sharingXml = "PublishSubscribe";
            }
          else
            {
              objModel.sharingXml = "Publish";
            }
        }
      else if (objPuBSub && (objPuBSub.subscribe ||
                             (objPuBSub.maySubscribe && hasOwn)))
        {
          objModel.sharingXml = "Subscribe";
        }
      else
        {
          objModel.sharingXml = "Neither";
        }
      
      // Here, objectTraverserXml calls itself recursively to
      // generate XML for the children before generating
      // XML for the parent.
      // We do not want to include the FederateObject.
      object.children.forEach(function(child)
      {
        if ((child.name != "FederateObject") &&
            (child.id in federate.pubSubObjects))
          {
            objModel.children.push
              (objectTraverserXml(federate, child, space + "    "));
          }
      });
      // now generate XML for the parent if on pubSubObjects
      if (object.id in federate.pubSubObjects)
        {
          return ejs.render(TEMPLATES["fedfile_simobject_xml.ejs"], objModel);
        }
    };
   

/***********************************************************************/

/* interactionTraverserCheck (function-valued var of top-level function object)

Returned Value: none

Called By:
  anonyomous fom generator in FederatesExporter.prototype.main
  interactionTraverserCheck (recursively)

This adds entries to the pubSubInteractions of a federate for all ancestors
of interactions that already have entries.

By calling itself recursively, this goes through the interaction tree
(from top down) but builds the pubSubInteractions from bottom up.

If an interaction is on the pubSubInteractions of the federate but its
parent is not, an entry for the parent of the interaction is added to
the pubSubInteractions; the entry represents that the parent neither
publishes or subscribes. If the parent publishes or subscribes, an
entry for the parent will have been made previously in PubSubVisitors.

The final effect is that any interaction that is an ancestor of any
interaction originally put on the pubSubInteractions in PubSubVisitors
is also on pubSubInteractions.

*/
    interactionTraverserCheck = function( /* ARGUMENTS                       */
     federate,                            /* (object) federate of interest   */
     interaction)                         /* (object) interaction to process */
    {
      interaction.children.forEach(function (child)
      {
        interactionTraverserCheck(federate, child);
      });
      if (interaction.name != 'InteractionRoot')
        {
          if ((interaction.id in federate.pubSubInteractions) &&
              !(interaction.basePath in federate.pubSubInteractions))
            {
              federate.pubSubInteractions[interaction.basePath] =
                {publish: 0,
                 subscribe: 0};
            }
        }
    };

/***********************************************************************/

/* interactionTraverserXml (function-valued var of top-level function object)

Returned Value: a string of XML representing the interaction and its
                descendants

Called By:
  anonyomous fom generator in FederatesExporter.prototype.main
  interactionTraverserXml (recursively)

interactionTraverserXml is a recursive function that builds the XML
for interactions in a federate.

The function takes information about a federate and takes an interaction
that may have children (also interactions).

The function begins by creating an intModel. The intModel is given the
same name and parameters as the interaction and is given children that are
XML code built by a recursive call to the function on the children of
the interaction.  The intModel is also given other properties needed for
generating XML.

Then XML for the intModel is generated from the intModel (and saved)
by calling ejs.render using the fedfile_siminteraction_xml XML Template.

*/
    interactionTraverserXml = function( /* ARGUMENTS                       */
     federate,                          /* (object) federate of interest   */
     interaction,                       /* (object) interaction to process */
     space)                             /* (string) indentation space      */
    {
      var intModel;
      var intPubSub;

      intModel = {name: interaction.name,
                  sharingXml: 0,
                  deliveryXml: 0,
                  orderXml: 0,
                  indent: space,
                  parameters: interaction.parameters,
                  children: []};
      intPubSub = federate.pubSubInteractions[interaction.id];
      if (intPubSub && intPubSub.publish)
        {
          if (intPubSub.subscribe)
            {
              intModel.sharingXml = "PublishSubscribe";
            }
          else
            {
              intModel.sharingXml = "Publish";
            }
        }
      else if (intPubSub && intPubSub.subscribe)
        {
          intModel.sharingXml = "Subscribe";
        }
      else
        {
          intModel.sharingXml = "Neither";
        }
      if (interaction.delivery === "reliable")
        {
          intModel.deliveryXml = "HLAreliable";
        }
      else
        {
          interaction.deliveryXml = "HLAbestEffort";
        }
      if (interaction.order === "timestamp")
        {
          intModel.orderXml = "TimeStamp";
        }
      else
        {
          intModel.orderXml = "Receive";
        }
      // here interactionTraverserXml calls itself recursively to
      // generate XML for the children before generating
      // XML for the parent
      interaction.children.forEach(function (child)
      {
        if (child.id in federate.pubSubInteractions)
          {
            intModel.children.push
              (interactionTraverserXml(federate, child, space + "    "));
          }
      });
      
      // now generate XML for the parent if on pubSubInteractions
      if (interaction.id in federate.pubSubInteractions)
        {
          return ejs.render(TEMPLATES["fedfile_siminteraction_xml.ejs"],
                            intModel);
        }
    };
            
/***********************************************************************/

/* fomGenerator (function-valued variable of top-level function object)

Returned Value: none

Called By: finishExport

This builds a file generator that generates a separate fom file for each
federate in a project.

Where fedEx.objectRoots.forEach is called, objectTraverserXml will
return undefined if there is no XML for objects. In that case,
objectsXml will have length 1, but objectsXml[0] will be undefined.

The call to the callback function with no argument evidently triggers
printing all the files that have been put into the artifact. If callback
is called each time around the loop below, a zip file is generated each
time containing one more fom file than the preceding zip file. Hence
that call can be made only once. In addition, webGME complains if
callback is called more than once.

*/
    fomGenerator = function( /* ARGUMENTS                             */
     fedEx)                  /* the FederatesExporter function object */
    {
      var today = new Date();
      var year = today.getFullYear();
      var month = today.getMonth();
      var day = today.getDate();
      var dateString = (year + "-" + ((month < 10) ? "0" : "") + month +
                        "-" + ((day < 10) ? "0" : "") + day);
      var fomModelXml;      // model from which to generate XML
      var federId;          // id of federate  
      var feder;            // data for federate in federateInfos
      var endJoinResignId;  // id of a 
      var directory;        // SOM.xml output directory    
      var endJoinResign;
      var remaining;

      remaining = Object.keys(fedEx.federateInfos).length;
      console.log("adding fom generator to file generators");
      fedEx.fileGenerators.push(function(artifact, callback)
      {
        for (federId in fedEx.federateInfos)
          {
            remaining--;
            feder = fedEx.federateInfos[federId];
            directory = feder.directory || 'som/';
            console.log("generating fom file for " + feder.name);

            fomModelXml =
              {federateName: feder.name,
               projectName: fedEx.projectName,
               version: fedEx.getCurrentConfig().exportVersion.trim(),
               pocOrg: fedEx.mainPom.groupId,
               dateString: dateString,
               objectsXml: [],
               interactionsXml: []};
            fedEx.interactionRoots.forEach(function (interactionRoot)
            {
              for (endJoinResignId in fedEx.endJoinResigns)
                {
                  endJoinResign = fedEx.endJoinResigns[endJoinResignId];
                  addEndJoinResign(endJoinResign.name,
                                   feder.pubSubInteractions, endJoinResignId);
                }
              interactionTraverserCheck(feder, interactionRoot);
              fomModelXml.interactionsXml.push
                (interactionTraverserXml(feder, interactionRoot, "    "));
            });
            fedEx.objectRoots.forEach(function(objectRoot)
            {
              objectTraverserCheck(feder, objectRoot);
              fomModelXml.objectsXml.push
                (objectTraverserXml(feder, objectRoot, "    "));
            });
            // add fom XML files to artifact
            if (remaining)
              { // there are more files after this one
                artifact.addFile(directory + feder.name + '.xml',
                                 ejs.render(TEMPLATES['fedfile.xml.ejs'],
                                            fomModelXml),
                                 function (err)
                                 {
                                   if (err)
                                     {
                                       callback(err);
                                       return;
                                     }
                                 });
              }
            else
              { // this is the last file
                artifact.addFile(directory + feder.name + '.xml',
                                 ejs.render(TEMPLATES['fedfile.xml.ejs'],
                                            fomModelXml),
                                 function (err)
                                 {
                                   if (err)
                                     {
                                       callback(err);
                                       return;
                                     }
                                   else
                                     {
                                       callback();
                                     }
                                 });
              }
          }
      });
    };
      
/***********************************************************************/
    
/* FederatesExporter.prototype.main

Returned Value: none

Called By: ?

Notes autogenerated or from previous coder:
-------------------------------------------

    This is the main function for the plugin to execute. This will perform
    the execution.

    Use self to access core, project, result, etc from PluginBase;
    these are all instantiated at this point.

    Do NOT put any user interaction logic UI, etc. inside this method.
    callback always has to be called even if error happened.

    @param {function(string, plugin.PluginResult)} callback -
    the result callback
---------------------------------------

*/
    console.log("defining FederatesExporter.prototype.main");
    FederatesExporter.prototype.main = function(
     callback)
    {
      var self = this;            // federates exporter function
      var feder;                  // for-in variable
      var generateFiles;          // function
      var numberOfFileGenerators; // counter used in generateFiles function
      var finishExport;           // function
      var saveAndReturn;          // function

      console.log("executing FederatesExporter.prototype.main");
      self.fileGenerators = [];
      self.corefileGenerators = [];
      self.fom_sheets = {};
      self.interactions = {};
      self.interactionRoots = [];
      self.objects      = {};
      self.objectRoots = [];
      self.attributes   = {};
      self.federates = {};
      self.javafederateName = {};
      self.fedFilterMap = {};
      self.fedFilterMap["MAPPER_FEDERATES"] = "MAPPER";
      self.fedFilterMap["NON-MAPPER_FEDERATES"] = "NON_MAPPER";
      self.fedFilterMap["BOTH"] = "ORIGIN_FILTER_DISABLED";
      self.fedFilterMap["SELF"] = "SELF";
      self.fedFilterMap["NON-SELF"] = "NON_SELF";
      
      self.projectName = self.core.getAttribute(self.rootNode, 'name');
      self.project_version =
      self.getCurrentConfig().exportVersion.trim() +
      (self.getCurrentConfig().isRelease ? "" : "-SNAPSHOT");
      self.cpswt_version = self.getCurrentConfig().cpswtVersion.trim();
      self.directoryNameTemplate=
      '<%=federation_name%><%=artifact_name?"-"+artifact_name:""%><%=language?"-"+language:""%>';
      self.generateExportPackages =
        self.getCurrentConfig().generateExportPackages;
      self.mainPom.artifactId = self.projectName + "-root";
      self.mainPom.version = self.project_version;
      self.mainPom.packaging = "pom";
      self.mainPom.groupId = self.getCurrentConfig().groupId.trim();
      self.mainPom.addRepository(
        {
           'id': 'archiva.internal',
           'name': 'Internal Release Repository',
           'url': self.getCurrentConfig().repositoryUrlRelease.trim()
        });
        
      self.mainPom.addSnapshotRepository(
        {
           'id': 'archiva.snapshots',
           'name': 'Internal Snapshot Repository',
           'url': self.getCurrentConfig().repositoryUrlSnapshot.trim()
        });

      self.getCurrentConfig().includedFederateTypes.trim().split(" ").
        forEach(function(e)
          {
            if (self.federateTypes.hasOwnProperty(e))
              {
                self.federateTypes[e].includeInExport = true;
                if (self.federateTypes[e].hasOwnProperty('init'))
                  {
                    self.federateTypes[e].init.call(self); 
                  }
              }
          });
      
/***********************************************************************/
      
      console.log("adding pom generator to file generators");
      //Add POM generator to file generators
      self.fileGenerators.push(function(artifact, callback)
      { // add POM file to artifact
        console.log("executing pom generator function in fileGenerators");
        artifact.addFile('pom.xml',
                         self._jsonToXml.convertToString(self.mainPom.
                                                         toJSON()),
                         function (err)
                         {
                           if (err)
                             {
                               callback(err);
                               return;
                             }
                           else
                             {
                               callback();
                             }
                         });
      });

/***********************************************************************/

/* generateFiles (function-valued variable of FederatesExporter.prototype.main)

Returned Value: none

Called By:
  finishExport
  generateFiles (recursively)

This generates the text of files to be included in the output. It executes
one file generating function on each recursive call.

*/      

      generateFiles = function( /* ARGUMENTS                                */
       artifact,                /* (object) see above                       */
       fileGenerators,          /* (array) of functions that generate files */
       doneBack)                /* (?) function                             */
      {
        if (numberOfFileGenerators > 0)
          { 
            fileGenerators[fileGenerators.length -
                           numberOfFileGenerators](artifact, function(err)
              {
                if (err)
                  {
                    callback(err, self.result);
                    return;
                  }
                numberOfFileGenerators--;
                if (numberOfFileGenerators > 0)
                  {
                    generateFiles(artifact, fileGenerators, doneBack);
                  }
                else
                  {
                    doneBack();
                  }
              });                
          }
        else
          {
            doneBack();
          }
      };

/***********************************************************************/

/* saveAndReturn (function-valued variable of FederatesExporter.prototype.main)

Returned Value: none

Called By: finishExport

This function is defined as a variable of FederatesExporter.prototype.main.
It uses the self variable.

*/      

      saveAndReturn = function( /* ARGUMENTS                             */
       err)                     /* (string)  an error string or null (?) */
      {
        var errorRaised;
        var i;
        var msg;
        var idx;
        var artifactMsg;
        var buildURL;
        
        errorRaised = false;
        for (i = 0; i < self.result.getMessages().length; i++)
          {
            msg = self.result.getMessages()[i];
            if (msg.severity == 'error')
              {
                errorRaised = true;
              }
          }
        if (!errorRaised)
          {
            self.blobClient.saveAllArtifacts(function (err, hashes)
            {
              if (err)
                {
                  callback(err, self.result);
                  return;
                }
              // comment from previous coder:
              // This will add a download hyperlink in the result-dialog.
              for (idx = 0; idx < hashes.length; idx++)
                {
                  self.result.addArtifact(hashes[idx]);
                  
                  artifactMsg =
                    'Code package ' +
                    self.blobClient.artifacts[idx].name +
                    ' was generated with id:[' + hashes[idx] + ']';
                  buildURL =
                    "'http://c2w-cdi.isis.vanderbilt.edu:8080/job/c2w-pull/buildW ithParameters?GME_ARTIFACT_ID=" + hashes[idx] + "'";
                  artifactMsg += '<br><a title="Build package..." '+
                    'onclick="window.open(' + buildURL + ', \'Build System\'); return false;">Build artifact..</a>';
                  self.createMessage(null, artifactMsg );
                };
              // comment from previous coder:
              // This will save the changes. If you don't want to save;
              // exclude self.save and call callback directly from this
              // scope.
              self.save('FederatesExporter updated model.', function (err)
                {
                  if (err)
                    {
                      callback(err, self.result);
                      return;
                    }
                  self.result.setSuccess(true);
                  callback(null, self.result);
                  return;
                });
            });
          }
        else
          {
            self.result.setSuccess(false);
            callback(null, self.result);
            return;
          }
      };
       
/***********************************************************************/

/* finishExport (function-valued variable of FederatesExporter.prototype.main)

Returned Value: none

Called By: anonymous function used as an argument to 
  visitAllChildrenFromRootContainer

This function is defined as a variable of FederatesExporter.prototype.main.
It uses the self variable.


*/      

      finishExport = function( /* ARGUMENTS                            */
       err)                    /* (string) an error string or null (?) */
      {
        var artifact;
        var coreArtifact;
        
        artifact =
          self.blobClient.createArtifact(self.projectName.trim().
                                         replace(/\s+/g,'_') + '_generated');
        console.log("start executing finishExport");
        fomGenerator(self);
        if (self.generateExportPackages)
          {
            coreArtifact =
              self.blobClient.createArtifact('generated_Core_Files');
          }
        numberOfFileGenerators = self.fileGenerators.length;
        if (numberOfFileGenerators > 0)
          {
            generateFiles(artifact, self.fileGenerators, function(err)
            {
              if (err)
                {
                  callback(err, self.result);
                  return;
                }
              numberOfFileGenerators = self.corefileGenerators.length;
              if (self.generateExportPackages &&
                  numberOfFileGenerators > 0)
                {
                  generateFiles(coreArtifact,
                                self.corefileGenerators, function(err)
                    {
                      if (err)
                        {
                          callback(err, self.result);
                          return;
                        }
                      saveAndReturn();
                      return;
                    });
                }
              else
                {
                  saveAndReturn();
                  return;
                } 
            });
          }
        else
          {
            console.log("done generating files in finishExport");
            self.result.setSuccess(true);
            callback(null, self.result);
          } 
        console.log("end executing finishExport");
      };
       
/***********************************************************************/

/*

This is a call to the visitAllChildrenFromRootContainer function (!) which
is defined in ModelTraverserMixin.js. The anonymous function is the second
argument.

*/
      
      self.visitAllChildrenFromRootContainer(self.rootNode, function(err)
        {
          if (err)
            {
              self.logger.error(err);
              self.createMessage(null, err, 'error');
              self.result.setSuccess(false);
              callback(null, self.result);
            }
          else
            {
              finishExport(err);
            }
        }); 
      
/***********************************************************************/

      self.postAllVisits(self);
    }; // end of FederatesExporter.prototype.main

/***********************************************************************/

/* FederatesExporter.prototype.getChildSorterFunc

This defines the FederatesExporter.prototype.getChildSorterFunc function
that defines a function to be passed to a sorting routine. The function
to be passed to a sorting routine takes pointers to two attributes (a and b)
and implements the rules:
  If the name of a is less than the name of b, return -1.
  Otherwise, if the name of a is greater than the name of b, return 1.
  Otherwise, return 0.

This is a very strange function because it does not use either of its
arguments. It is not clear whether this function is used anywhere.

*/    
    FederatesExporter.prototype.getChildSorterFunc = function(
     nodeType, // argument not used
     self)     // argument not used (overridden by var also named self)
    {
      var self;
      var generalChildSorter;
      var aName;
      var bName;
      
      self = this; // overrides self argument
      generalChildSorter = function(a, b)
      {
        aName = self.core.getAttribute(a,'name');
        bName = self.core.getAttribute(b,'name');
        if (aName < bName) return -1;
        if (aName > bName) return 1;
        return 0;
      };
      return generalChildSorter;
    };
   
/***********************************************************************/

/* excludeFromVisit (function property of FederatesExporter.prototype)

Returned Value: true or false

Called By: ? does not appear to be called anywhere

A function named excludeFromVisit is also defined (and called) in
ModelTraverserMixin.js.

*/

    FederatesExporter.prototype.excludeFromVisit = function(node)
    {
      var self;
      var exclude;
      var nodeTypeName;
      
      self = this,
      exclude = false;
      
      if (self.rootNode != node)
        {    
          nodeTypeName =
            self.core.getAttribute(self.getMetaType(node),'name');
          exclude = exclude 
            || self.isMetaTypeOf(node, self.META['Language [C2WT]'])
            || (self.federateTypes.hasOwnProperty(nodeTypeName) &&
                !self.federateTypes[nodeTypeName].includeInExport);
        }
      return exclude;
    };

/***********************************************************************/

/* getVisitorFuncName (function property of FederatesExporter.prototype)

Returned Value: a visitor function name

Called By: atModelNode in ModelTraverserMixin.js

This is defining the getVisitorFuncName function as a property of the
prototype of FederatesExporter. The getVisitorFuncName function is
also defined as a property of "this" in ModelTraverserMixin.js, but
the one that gets called when the FederatesExporter is executing is
this one.

*/
    
    FederatesExporter.prototype.getVisitorFuncName = function(
     nodeType) // (string) the name of a type of node or null
    {
      var visitorName = 'generalVisitor';
      if (nodeType)
        {
          visitorName = 'visit_'+ nodeType;
          if (nodeType.endsWith('Federate'))
            {
              visitorName = 'visit_'+ 'Federate';
            }
        }
      return visitorName;   
    };

/***********************************************************************/

/* getPostVisitorFuncName (function property of FederatesExporter.prototype)

*/
    
    FederatesExporter.prototype.getPostVisitorFuncName = function(nodeType)
    {
      var self = this,
      visitorName = 'generalPostVisitor';
      
      if (nodeType)
        {
          visitorName = 'post_visit_'+ nodeType;
          if (nodeType.endsWith('Federate'))
            {
              visitorName = 'post_visit_'+ 'Federate';
            }
        }
      return visitorName;
    };

/***********************************************************************/

    FederatesExporter.prototype.ROOT_visitor = function(node)
    {
      var self = this;
      var root = {"@id": 'model:' + '/root',
                  "@type": "gme:root",
                  "model:name": self.projectName,
                  "gme:children": []};
      return {context:{parent: root}};
    };

/***********************************************************************/

    FederatesExporter.prototype.calculateParentPath = function(path)
    {
      if (!path)
        {
          return null;
        }
      var pathElements = path.split('/');
      pathElements.pop();
      return pathElements.join('/');
    };
    
/***********************************************************************/

    return FederatesExporter;
 });
