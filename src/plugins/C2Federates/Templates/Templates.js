//jshint ignore: start
/* Generated file based on ejs templates */
define([], function() {
    return {
    "cpp/class.cpp.ejs": "<% /*class(isinteraction,simname,classname,parentclassname,hlaclassname,datamembers,alldatamembers,isc2winteractionroot) ::= <<*/ -%>\n// This file was generated by the WebGME Federates Exporter plugin. Do not edit manually!\n\n#include \"<%=classname%>.hpp\"\n\n<% /*classcommon(...)*/ -%>\n<%- ejs.render(TEMPLATES[\"cpp/classcommon.cpp.ejs\"], {\n\t\tisinteraction: isinteraction,\n\t\tclassname: classname,\n\t\tparentclassname: parentclassname,\n\t\thlaclassname: hlaclassname,\n\t\tdatamembers: datamembers,\n\t\talldatamembers: alldatamembers\n}) -%>\n<% if(isc2winteractionroot){ -%>\n\nvoid C2WInteractionRoot::sendInteraction( RTI::RTIambassador *rti, double time ) {\n\tif ( get_sourceFed().empty() || get_originFed().empty() ) {\n\t\tthrow C2WException( \"C2WInteractionRoot::sendInteraction:  source and/or origin federate not specified.\" );\n\t}\n\tSuper::sendInteraction( rti, time );\n}\n\nvoid C2WInteractionRoot::sendInteraction( RTI::RTIambassador *rti ) {\n\tif ( get_sourceFed().empty() || get_originFed().empty() ) {\n\t\tthrow C2WException( \"C2WInteractionRoot::sendInteraction:  source and/or origin federate not specified.\" );\n\t}\n\tSuper::sendInteraction( rti );\n}\n<% } -%>\n<% if(!isinteraction){ -%>\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\n\n<%=classname%>::AttributeHandleValuePairSetSP <%=classname%>::createDatamemberHandleValuePairSet( bool force ) {\n\tAttributeHandleValuePairSetSP datamembers = AttributeHandleValuePairSetSP(RTI::AttributeSetFactory::create(<%=alldatamembers.length%>));\n\tstd::string stringConversion;\n\tbool isPublished;\n\n<% /*alldatamembers:{ d |<supplied_attribute(classname=classname,datamember=d)>}*/ -%>\n<% alldatamembers.forEach(function(datamember){ -%>\n\tisPublished = (m_publishedAttributeNames.find(\"<%=datamember.name%>\") != m_publishedAttributeNames.end());\n\tif (  isPublished && _<%=datamember.name%>.shouldBeUpdated( force )  ) {\n\t\tstringConversion = static_cast< std::string >(  TypeMedley( get_<%=datamember.name%>() )  );\n\t\tdatamembers->add( get_<%=datamember.name%>_handle(), stringConversion.c_str(), stringConversion.size() );\n\t\t_<%=datamember.name%>.setHasBeenUpdated();\n\t}\n\n<% }); -%>\n\treturn datamembers;\n}\n\nboost::unordered_set< std::string > <%=classname%>::m_publishedAttributeNames;\n<% } -%>\n<% } -%>\n",
    "cpp/class.hpp.ejs": "<% /*class(isinteraction,simname,classname,parentclassname,hlaclassname,datamembers,alldatamembers,isc2winteractionroot) ::= << */ -%>\n// This file was generated by the WebGME Federates Exporter plugin. Do not edit manually!\n\n/*\n * Copyright (c) 2008, Institute for Software Integrated Systems, Vanderbilt University\n * All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this software and its\n * documentation for any purpose, without fee, and without written agreement is\n * hereby granted, provided that the above copyright notice, the following\n * two paragraphs and the author appear in all copies of this software.\n *\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n */\n\n/*\n * \tNOTE:  ALL \"if\" STATEMENTS IN THIS CODE THAT HAD THE FORM:\n *\n *  if (condition) statement;\n *\n *\tOR\n *\n *  if (condition) statement1;\n *  else           statement2;\n *\n *  HAVE BEEN CONVERTED TO THE FORMS:\n *\n *  if (condition) {\n *\t\tstatement;\n *\t}\n *\n *\tAND\n *\n *  if (condition) {\n *\t\tstatement1;\n *\t} else {\n *\t\tstatement2;\n *\t}\n *\n *\tRESPECTIVELY.  THIS IS BECAUSE THE OMNET DEBUGGER APPEARS TO HAVE A PROBLEM\n *  WITH THE NON-BRACED FORMS OF THE IF STATEMENT.  *PLEASE* DO NOT CHANGE IT BACK.\n *  -- H.S.N.\n *\n */\n\n#ifndef _<%=classname%>_CLASS\n#define _<%=classname%>_CLASS\n\n#include \"<%=parentclassname%>.hpp\"\n#include \"C2WException.hpp\"\n<% if(!isinteraction){ -%>\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\n\n#include <boost/unordered_set.hpp>\n<% }} -%>\n\nclass <%=classname%> : public <%=parentclassname%> {\npublic:\n\ttypedef <%=parentclassname%> Super;\n\ttypedef boost::shared_ptr< <%=classname%> > SP;\n\n\tstatic StringVector get_<%=isinteraction?\"parameter\":\"attribute\"%>_names() {\n\t\treturn getDatamemberNames();\n\t}\n\n\tstatic StringVector get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names() {\n\t\treturn getAllDatamemberNames();\n\t}\n\n\t<%=classname%>( void ) { }\n\n\tstatic SP create( void ) { return SP( new <%=classname%> ); }\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\n\nprivate:\n<% if(!isinteraction){ -%>\n\tstatic boost::unordered_set< std::string > m_publishedAttributeNames;\n\n<% } -%>\n<% /*alldatamembers:handle()*/ -%>\n<% alldatamembers.forEach(function(datamember){ -%>\n\tstatic int &get_<%=datamember.name%>_handle_var( void ) {\n\t\tstatic int <%=datamember.name%>_handle;\n\t\treturn <%=datamember.name%>_handle;\n\t}\n\n<% }); -%>\npublic:\n<% /*alldatamembers:gethandle()*/ -%>\n<% alldatamembers.forEach(function(datamember){ -%>\n\tstatic int get_<%=datamember.name%>_handle( void ) { return get_<%=datamember.name%>_handle_var(); }\n<% }); -%>\n<% } -%>\n\n<% /*classcommon(...)*/ -%>\n<%- ejs.render(TEMPLATES[\"cpp/classcommon.hpp.ejs\"], {\n\t\tisinteraction: isinteraction,\n\t\tclassname: classname,\n\t\tparentclassname: parentclassname,\n\t\thlaclassname: hlaclassname,\n\t\tdatamembers: datamembers,\n\t\talldatamembers: alldatamembers\n}) -%>\n<% if(isc2winteractionroot){ -%>\n\npublic:\n\tvoid sendInteraction( RTI::RTIambassador *rti, double time );\n\tvoid sendInteraction( RTI::RTIambassador *rti );\n<% } -%>\n<% if(isinteraction){ -%>\n<% if(datamembers && datamembers.length > 0){ -%>\n\nprivate:\n<% /*datamembers:interactionmembers()*/ -%>\n<% datamembers.forEach(function(datamember){ -%>\n\t<%- helpers.cppjavaTypeMap(datamember.parameterType) %> _<%=datamember.name%>;\n<% }); -%>\n\npublic:\n<% /*datamembers:interactiongetters()*/ -%>\n<% datamembers.forEach(function(datamember){ -%>\n\tvoid set_<%=datamember.name%>( <%- helpers.cppjavaArgumentTypeMap(datamember.parameterType) %> <%=datamember.name%> ) { _<%=datamember.name%> = <%=datamember.name%>; }\n\n\t<%- helpers.cppjavaArgumentTypeMap(datamember.parameterType) %> get_<%=datamember.name%>( void ) const { return _<%=datamember.name%>; }\n\n<% }); -%>\n<% } -%>\n<% }else{ -%>\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\n\npublic:\n<% alldatamembers.forEach(function(attribute){ -%>\n<% /*alldatamembers:{ a |<publish(classname=classname,attribute=a)> }*/ -%>\n\tstatic void publish_<%=attribute.name%>( void ) {\n\t\tgetPublishAttributeNameVector().push_back( \"<%=attribute.name%>\" );\n\t\tm_publishedAttributeNames.emplace( \"<%=attribute.name%>\" );\n\t}\n\n\tstatic void unpublish_<%=attribute.name%>( void ) {\n\t\tgetPublishAttributeNameVector().erase( std::remove( getPublishAttributeNameVector().begin(), getPublishAttributeNameVector().end(), \"<%=attribute.name%>\" ), getPublishAttributeNameVector().end() );\n\t\tm_publishedAttributeNames.erase( \"<%=attribute.name%>\" );\n\t}\n\n<% /*alldatamembers:{ a |<subscribe(classname=classname,attribute=a)> }*/ -%>\n\tstatic void subscribe_<%=attribute.name%>( void ) {\n\t\tgetSubscribeAttributeNameVector().push_back( \"<%=attribute.name%>\" );\n\t}\n\n\tstatic void unsubscribe_<%=attribute.name%>(void ) {\n\t\tgetSubscribeAttributeNameVector().erase( std::remove( getSubscribeAttributeNameVector().begin(), getSubscribeAttributeNameVector().end(), \"<%=attribute.name%>\" ), getSubscribeAttributeNameVector().end() );\n\t}\n\n<% }); -%>\nprotected:\n<% /*datamembers:objectmembers()*/ -%>\n<% datamembers.forEach(function(datamember){ -%>\n\tAttribute< int, <%- helpers.cppjavaTypeMap(datamember.parameterType) %> > _<%=datamember.name%>;\n<% }); -%>\n\npublic:\n<% datamembers.forEach(function(datamember){ -%>\n<% /*datamembers:objectsetters()*/ -%>\n\tvoid set_<%=datamember.name%>( <%- helpers.cppjavaArgumentTypeMap(datamember.parameterType) %> <%=datamember.name%> ) {\n\t\t_<%=datamember.name%>.setValue( <%=datamember.name%> );\n\t\t_<%=datamember.name%>.setTime( getTime() );\n\t}\n\n<% /*datamembers:objectgetters()*/ -%>\n\t<%- helpers.cppjavaArgumentTypeMap(datamember.parameterType) %> get_<%=datamember.name%>( void ) const {\n\t\treturn _<%=datamember.name%>.getValue();\n\t}\n\n<% /*datamembers:objecttimegetters()*/ -%>\n\tdouble get_<%=datamember.name%>_time( void ) {\n\t\treturn _<%=datamember.name%>.getTime();\n\t}\n\n<% }); -%>\n<% } -%>\n<% } -%>\n\t<%=classname%>( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap ) : Super( datamemberMap ) { }\n\n\t<%=classname%>( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap, const RTIfedTime &logicalTime ) : Super( datamemberMap, logicalTime ) { }\n<% if(datamembers && datamembers.length > 0){ -%>\n\npublic:\n\tTypeMedley get<%=isinteraction?\"Parameter\":\"Attribute\"%>( const std::string &datamemberName ) const {\n<% /*first(datamembers):startgetbyname()*/ -%>\n<% for(var i = 0; i<datamembers.length; i++ ){ -%>\n<%= i == 0  ? '\t\tif' : ' else if' %> ( \"<%=datamembers[i].name%>\" == datamemberName ) {\n\t\t\treturn TypeMedley( get_<%=datamembers[i].name%>() );\n\t\t}<%}%> else {\n\t\t\treturn Super::get<%=isinteraction?\"Parameter\":\"Attribute\"%>( datamemberName );\n\t\t}\n\t}\n\nprotected:\n\tvirtual bool set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( const std::string &datamemberName, const std::string &val ) {\n\t\tbool retval = true;\n<% /*first(datamembers):startifstring()*/ -%>\n<% for(var i = 0; i<datamembers.length; i++ ){ -%>\n<%= i == 0  ? '\t\tif' : ' else if'%> ( \"<%=datamembers[i].name%>\" == datamemberName ) {\n\t\t\tset_<%=datamembers[i].name%>(  TypeMedley( val )  );\n\t\t}<%}%> else {\n\t\t\tretval = Super::set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( datamemberName, val );\n\t\t}\n\n\t\treturn retval;\n\t}\n\n\tvirtual bool set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( const std::string &datamemberName, const TypeMedley &val ) {\n\t\tbool retval = true;\n<% /*first(datamembers):startifname()*/ -%>\n<% for(var i = 0; i<datamembers.length; i++ ){ -%>\n<%= i == 0  ? '\t\tif' : ' else if'%> ( \"<%=datamembers[i].name%>\" == datamemberName ) {\n\t\t\tset_<%=datamembers[i].name%>( val );\n\t\t}<%}%> else {\n\t\t\tretval = Super::set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( datamemberName, val );\n\t\t}\n\n\t\treturn retval;\n\t}\n<% if(!isinteraction){ -%>\n\n\tvirtual AttributeHandleValuePairSetSP createDatamemberHandleValuePairSet( bool force );\n<% } -%>\n<% } -%>\n};\n\ntypedef <%=classname%>::SP <%=classname%>SP;\n\nstatic bool call_<%=classname%>_static_init = <%=classname%>::static_init();\n\nstd::ostream &operator<<( std::ostream &os, <%=classname%>::SP entitySP );\nstd::ostream &operator<<( std::ostream &os, const <%=classname%> &entity );\n\n#endif\n",
    "cpp/classcommon.cpp.ejs": "<% /*classcommon(isinteraction,classname,parentclassname,hlaclassname,datamembers,alldatamembers) ::= << */ -%>\nvoid <%=classname%>::init( RTI::RTIambassador *rti ) {\n\tstatic bool isInitialized = false;\n\tif ( isInitialized ) {\n\t\treturn;\n\t}\n\tisInitialized = true;\n<% if(parentclassname){ -%>\n\n\t<%=parentclassname%>::init( rti );\n<% } -%>\n\n\tbool isNotInitialized = true;\n\twhile( isNotInitialized ) {\n\t\ttry {\n\t\t\tgetHandle() = rti->get<%=isinteraction?\"Interaction\":\"Object\"%>ClassHandle( \"<%=hlaclassname%>\" );\n\t\t\tisNotInitialized = false;\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\n\t\t\tstd::cerr << getInitErrorMessage() << \"Federate Not Execution Member\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::NameNotFound & ) {\n\t\t\tstd::cerr << getInitErrorMessage() << \"Name Not Found\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( ... ) {\n\t\t\tstd::cerr << getInitErrorMessage() << \"Exception caught ... retry\" << std::endl;\n\t\t}\n\t}\n\n\tgetClassNameHandleMap().insert(  std::make_pair( \"<%=classname%>\", get_handle() )  );\n\tgetClassHandleNameMap().insert(  std::make_pair( get_handle(), \"<%=classname%>\" )  );\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\n\n\tisNotInitialized = true;\n\twhile( isNotInitialized ) {\n\t\ttry {\n<% /*alldatamembers:handle_init()*/ -%>\n<% alldatamembers.forEach(function(datamember){ -%>\n\t\t\tget_<%=datamember.name%>_handle_var() = rti->get<%=isinteraction?\"Parameter\":\"Attribute\"%>Handle( \"<%=datamember.name%>\", get_handle() );\n<% }); -%>\n\t\t\tisNotInitialized = false;\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\n\t\t\tstd::cerr << getInitErrorMessage() << \"Federate Not Execution Member\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined & ) {\n\t\t\tstd::cerr << getInitErrorMessage() << \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::NameNotFound & ) {\n\t\t\tstd::cerr << getInitErrorMessage() << \"Name Not Found\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( ... ) {\n\t\t\tstd::cerr << getInitErrorMessage() << \"Exception caught ... retry\" << std::endl;\n\t\t}\n\t}\n<% alldatamembers.forEach(function(datamember){ -%>\n\n<% /*alldatamembers: { d |<initDatamemberNameHandleMap(classname=classname,datamember=d)>}*/ -%>\n\tgetDatamemberNameHandleMap().insert(  std::make_pair( \"<%=classname%>.<%=datamember.name%>\", get_<%=datamember.name%>_handle() )  );\n<% /*alldatamembers:initDatamemberHandleNameMap()*/ -%>\n\tgetDatamemberHandleNameMap().insert(  std::make_pair( get_<%=datamember.name%>_handle(), \"<%=datamember.name%>\" )  );\n<% /*alldatamembers:initDatamemberTypeMap()*/ -%>\n\tgetDatamemberTypeMap().insert( std::make_pair(\"<%=datamember.name%>\", \"<%=datamember.parameterType%>\") );\n<% }); -%>\n<% } -%>\n}\n\nvoid <%=classname%>::publish( RTI::RTIambassador *rti ) {\n\tif ( getIsPublished() ) {\n\t\treturn;\n\t}\n\n\tinit( rti );\n<% if(!isinteraction){ -%>\n\n\tgetPublishedAttributeHandleSet_var().empty();\n\tfor( StringVector::iterator stsItr = getPublishAttributeNameVector().begin() ; stsItr != getPublishAttributeNameVector().end() ; (void)++stsItr ) {\n\t\ttry {\n\t\t\tgetPublishedAttributeHandleSet_var().add(  getDatamemberNameHandleMap().find( \"<%=classname%>.\" + *stsItr )->second  );\n\t\t} catch ( ... ) {\n\t\t\tstd::cerr << getPublishErrorMessage() << \"Could not publish \\\"\" << *stsItr + \"\\\" attribute.\" << std::endl;\n\t\t}\n\t}\n<% } -%>\n\n\tbool isNotPublished = true;\n\twhile( isNotPublished ) {\n\t\ttry {\n\t\t\trti->publish<%=isinteraction?\"Interaction\":\"Object\"%>Class( get_handle()<% if(!isinteraction){ %>, getPublishedAttributeHandleSet_var()<%}%> );\n\t\t\tisNotPublished = false;\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\n\t\t\tstd::cerr << getPublishErrorMessage() << \"Federate Not Execution Member\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined & ) {\n\t\t\tstd::cerr << getPublishErrorMessage() << \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( ... ) {\n\t\t\tstd::cerr << getPublishErrorMessage() << \"Exception caught ... retry\" << std::endl;\n\t\t}\n\t}\n\n\tgetIsPublished() = true;\n}\n\nvoid <%=classname%>::unpublish( RTI::RTIambassador *rti ) {\n\tif ( !getIsPublished() ) {\n\t\treturn;\n\t}\n\n\tinit( rti );\n\n\tbool isNotUnpublished = true;\n\twhile( isNotUnpublished ) {\n\t\ttry {\n\t\t\trti->unpublish<%=isinteraction?\"Interaction\":\"Object\"%>Class( get_handle() );\n\t\t\tisNotUnpublished = false;\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\n\t\t\tstd::cerr << getUnpublishErrorMessage() + \"Federate Not Execution Member\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined & ) {\n\t\t\tstd::cerr << getUnpublishErrorMessage() + \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotPublished & ) {\n\t\t\tstd::cerr << getUnpublishErrorMessage() + \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Published\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( ... ) {\n\t\t\tstd::cerr << getUnpublishErrorMessage() << \"Exception caught ... retry\" << std::endl;\n\t\t}\n\t}\n\n\tgetIsPublished() = false;\n}\n\nvoid <%=classname%>::subscribe( RTI::RTIambassador *rti ) {\n\tif ( getIsSubscribed() ) {\n\t\treturn;\n\t}\n\n\tinit( rti );\n<% if(!isinteraction){ -%>\n\n\tgetSubscribedAttributeHandleSet_var().empty();\n\tfor(  StringVector::iterator sstItr = getSubscribeAttributeNameVector().begin() ; sstItr != getSubscribeAttributeNameVector().end() ; (void)++sstItr  ) {\n\t\ttry {\n\t\t\tgetSubscribedAttributeHandleSet_var().add(  getDatamemberNameHandleMap().find( \"<%=classname%>.\" + *sstItr )->second  );\n\t\t} catch ( ... ) {\n\t\t\tstd::cerr << getSubscribeErrorMessage() << \"Could not subscribe to \\\"\" << *sstItr << \"\\\" attribute.\" << std::endl;\n\t\t}\n\t}\n<% } -%>\n\n\tbool isNotSubscribed = true;\n\twhile( isNotSubscribed ) {\n\t\ttry {\n\t\t\trti->subscribe<% if(isinteraction){ %>InteractionClass( get_handle() )<% }else{ %>ObjectClassAttributes( get_handle(), getSubscribedAttributeHandleSet_var() )<%}%>;\n\t\t\tisNotSubscribed = false;\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\n\t\t\tstd::cerr << getSubscribeErrorMessage() << \"Federate Not Execution Member\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined & ) {\n\t\t\tstd::cerr << getSubscribeErrorMessage() << \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( ... ) {\n\t\t\tstd::cerr << getSubscribeErrorMessage() << \"Exception caught ... retry\" << std::endl;\n\t\t}\n\t}\n\n\tgetIsSubscribed() = true;\n}\n\nvoid <%=classname%>::unsubscribe( RTI::RTIambassador *rti ) {\n\tif ( !getIsSubscribed() ) {\n\t\treturn;\n\t}\n\n\tinit( rti );\n\n\tbool isNotUnsubscribed = true;\n\twhile( isNotUnsubscribed ) {\n\t\ttry {\n\t\t\trti->unsubscribe<%=isinteraction?\"Interaction\":\"Object\"%>Class( get_handle() );\n\t\t\tisNotUnsubscribed = false;\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\n\t\t\tstd::cerr << getUnsubscribeErrorMessage() << \"Federate Not Execution Member\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined & ) {\n\t\t\tstd::cerr << getUnsubscribeErrorMessage() << \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotSubscribed & ) {\n\t\t\tstd::cerr << getUnsubscribeErrorMessage() << \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Subscribed\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( ... ) {\n\t\t\tstd::cerr << getUnsubscribeErrorMessage() << \"Exception caught ... retry\" << std::endl;\n\t\t}\n\t}\n\n\tgetIsSubscribed() = false;\n}\n\nbool <%=classname%>::static_init( void ) {\n\tstatic bool isInitialized = false;\n\tif ( isInitialized ) {\n\t\treturn true;\n\t}\n\tisInitialized = true;\n\n\tgetClassNameSet().insert( \"<%=classname%>\" );\n\n\tgetClassNameFactoryMap().insert(  std::make_pair( \"<%=classname%>\", &<%=classname%>::factory )  );\n\tgetClassNamePublishMap().insert(   std::make_pair(  \"<%=classname%>\", (PubsubFunctionPtr)( &<%=classname%>::publish )  )   );\n\tgetClassNameUnpublishMap().insert(   std::make_pair(  \"<%=classname%>\", (PubsubFunctionPtr)( &<%=classname%>::unpublish )  )   );\n\tgetClassNameSubscribeMap().insert(   std::make_pair(  \"<%=classname%>\", (PubsubFunctionPtr)( &<%=classname%>::subscribe )  )   );\n\tgetClassNameUnsubscribeMap().insert(   std::make_pair(  \"<%=classname%>\", (PubsubFunctionPtr)( &<%=classname%>::unsubscribe )  )   );\n\n\tgetDatamemberClassNameVectorPtrMap().insert(  std::make_pair( \"<%=classname%>\", &getDatamemberNames() )  );\n\tgetAllDatamemberClassNameVectorPtrMap().insert(  std::make_pair( \"<%=classname%>\", &getAllDatamemberNames() )  );\n<% if(datamembers && datamembers.length > 0){ -%>\n\n<% /*datamembers:initDatamemberNameSet()*/ -%>\n<% datamembers.forEach(function(datamember){ -%>\n<% if(!datamember.hidden && !datamember.inherited){ -%>\n\tgetDatamemberNames().push_back( \"<%=datamember.name%>\" );\n<% } -%>\n<% }); -%>\n<% } -%>\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\n\n<% /*alldatamembers:initAllDatamemberNameSet()*/ -%>\n<% alldatamembers.forEach(function(datamember){ -%>\n\tgetAllDatamemberNames().push_back( \"<%=datamember.name%>\" );\n<% }); -%>\n<% } -%>\n<% if(!isinteraction){ -%>\n\n\tgetClassNamePublishAttributeNameVectorPtrMap().insert(  std::make_pair( \"<%=classname%>\", &getPublishAttributeNameVector() )  );\n\tgetClassNameSubscribeAttributeNameVectorPtrMap().insert(  std::make_pair( \"<%=classname%>\", &getSubscribeAttributeNameVector() )  );\n\n\tgetClassNamePublishedAttributesPtrMap().insert(  std::make_pair( \"<%=classname%>\", &getPublishedAttributeHandleSet_var() )  );\n\tgetClassNameSubscribedAttributesPtrMap().insert( std::make_pair( \"<%=classname%>\", &getSubscribedAttributeHandleSet_var() )  );\n<% } -%>\n\n\treturn true;\n}\n\nstd::ostream &operator<<( std::ostream &os, <%=classname%>::SP entitySP ) {\n\treturn os << *entitySP;\n}\nstd::ostream &operator<<( std::ostream &os, const <%=classname%> &entity ) {\n\treturn os << \"<%=classname%>(\"\n<% alldatamembers.forEach(function(datamember,i){ -%>\n\t\t\t<% if( i > 0){%><< \", \"<%}%> << \"<%=datamember.name%>:\" << entity.get_<%=datamember.name%>()\n<% }); -%>\n\t\t\t<< \")\";\n}\n",
    "cpp/classcommon.hpp.ejs": "<% /*classcommon(isinteraction,classname,parentclassname,hlaclassname,datamembers,alldatamembers) ::= <<*/ -%>\nprivate:\n\tstatic int &getHandle( void ) {\n\t\tstatic int handle;\n\t\treturn handle;\n\t}\n\npublic:\n\tstatic int get_handle( void ) { return getHandle(); }\n\tstatic std::string get_class_name( void ) { return \"<%=classname%>\"; }\n\nprivate:\n\tstatic StringVector &getDatamemberNames( void ) {\n\t\tstatic StringVector datamemberNames;\n\t\treturn datamemberNames;\n\t}\n\n\tstatic StringVector &getAllDatamemberNames( void ) {\n\t\tstatic StringVector allDatamemberNames;\n\t\treturn allDatamemberNames;\n\t}\n<% if(!isinteraction){ -%>\n\nprivate:\n\tstatic RTI::AttributeHandleSet &getPublishedAttributeHandleSet_var( void ) {\n\t\tstatic RTI::AttributeHandleSet *publishedAttributeHandleSetPtr = RTI::AttributeHandleSetFactory::create( <%= alldatamembers.length %> );\n\t\treturn *publishedAttributeHandleSetPtr;\n\t}\n\tstatic StringVector &getPublishAttributeNameVector( void ) {\n\t\tstatic StringVector publishAttributeNameVector;\n\t\treturn publishAttributeNameVector;\n\t}\n\n\tstatic RTI::AttributeHandleSet &getSubscribedAttributeHandleSet_var( void ) {\n\t\tstatic RTI::AttributeHandleSet *subscribedAttributeHandleSet = RTI::AttributeHandleSetFactory::create( <%= alldatamembers.length %> );\n\t\treturn *subscribedAttributeHandleSet;\n\t}\n\tstatic StringVector &getSubscribeAttributeNameVector( void ) {\n\t\tstatic StringVector subscribeAttributeNameVector;\n\t\treturn subscribeAttributeNameVector;\n\t}\n<% } -%>\n\nprivate:\n<% if(isinteraction){ -%>\n\tstatic InteractionRoot::SP factory( void ) {\n\t\treturn InteractionRoot::SP( new <%=classname%>() );\n\t}\n<% }else{ -%>\n\tstatic ObjectRoot::SP factory( void ) {\n\t\treturn ObjectRoot::SP( new <%=classname%>() );\n\t}\n<% } -%>\n\n\tstatic std::string &getInitErrorMessage( void ) {\n\t\tstatic std::string initErrorMessage( \"Error:  <%=classname%>:  could not initialize:  \" );\n\t\treturn initErrorMessage;\n\t}\n\nprotected:\n\tstatic void init( RTI::RTIambassador *rti );\n\nprivate:\n\tstatic bool &getIsPublished( void ) {\n\t\tstatic bool isPublished = false;\n\t\treturn isPublished;\n\t}\n\n\tstatic std::string &getPublishErrorMessage( void ) {\n\t\tstatic std::string publishErrorMessage = \"Error:  <%=classname%>:  could not publish:  \";\n\t\treturn publishErrorMessage;\n\t}\n\npublic:\n\tstatic void publish( RTI::RTIambassador *rti );\n\nprivate:\n\tstatic std::string &getUnpublishErrorMessage( void ) {\n\t\tstatic std::string unpublishErrorMessage = \"Error:  <%=classname%>:  could not unpublish:  \";\n\t\treturn unpublishErrorMessage;\n\t}\n\npublic:\n\tstatic void unpublish( RTI::RTIambassador *rti );\n\nprivate:\n\tstatic bool &getIsSubscribed( void ) {\n\t\tstatic bool isSubscribed = false;\n\t\treturn isSubscribed;\n\t}\n\tstatic std::string &getSubscribeErrorMessage( void ) {\n\t\tstatic std::string subscribedErrorMessage = \"Error:  <%=classname%>:  could not subscribe:  \";\n\t\treturn subscribedErrorMessage;\n\t}\n\npublic:\n\tstatic void subscribe( RTI::RTIambassador *rti );\n\nprivate:\n\tstatic std::string getUnsubscribeErrorMessage( void ) {\n\t\tstatic std::string unsubscribeErrorMessage = \"Error:  <%=classname%>:  could not unsubscribe:  \";\n\t\treturn unsubscribeErrorMessage;\n\t}\n\npublic:\n\tstatic void unsubscribe( RTI::RTIambassador *rti );\n\n\tstatic bool static_init( void );\n\n\tstatic bool match( int handle ) { return handle == get_handle(); }\n\n\tvirtual int getClassHandle( void ) const { return get_handle(); }\n\tvirtual std::string getClassName( void ) const { return get_class_name(); }\n\tvirtual StringVector get<%=isinteraction?\"Parameter\":\"Attribute\"%>Names( void ) const { return get_<%=isinteraction?\"parameter\":\"attribute\"%>_names(); }\n\tvirtual StringVector getAll<%=isinteraction?\"Parameter\":\"Attribute\"%>Names( void ) const { return get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names(); }\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\n\n\tvirtual std::string get<%=isinteraction?\"Parameter\":\"Attribute\"%>Name( int datamemberHandle ) const {\n<% for(var i = 0; i<alldatamembers.length; i++ ){ -%>\n<%= i == 0 ? '\t\tif' : ' else if'%> (datamemberHandle == get_<%=alldatamembers[i].name%>_handle()) {\n\t\t\treturn std::string(\"<%=alldatamembers[i].name%>\");\n\t\t}<% } %> else {\n<% if(parentclassname){ -%>\n\t\t\treturn <%=parentclassname%>::get<%=isinteraction?\"Parameter\":\"Attribute\"%>Name(datamemberHandle);\n<% } else { -%>\n\t\t\treturn std::string();\n<% } -%>\n\t\t}\n\t}\n<% } -%>\n\n\tvirtual void publish<%=isinteraction?\"Interaction\":\"Object\"%>( RTI::RTIambassador *rti ) { publish( rti ); }\n\tvirtual void subscribe<%=isinteraction?\"Interaction\":\"Object\"%>( RTI::RTIambassador *rti ) { subscribe( rti ); }\n\n\tvirtual <%=isinteraction?\"Interaction\":\"Object\"%>Root::SP clone( void ) {\n\t\treturn <%=isinteraction?\"Interaction\":\"Object\"%>Root::SP(  new <%=classname%>( *this )  );\n\t}\n<% if(!isinteraction){ -%>\n\n\tvirtual const RTI::AttributeHandleSet &getSubscribedAttributeHandleSet( void ) { return getSubscribedAttributeHandleSet_var(); }\n<% } -%>\n",
    "cpp/classroot.cpp.ejs": "<% /* THIS IS THE ROOT CLASS OF EITHER THE INTERACTION OR OBJECT-CLASS HEIRARCHY (I.E. \"InteractionRoot\" OR \"ObjectRoot\") */ %>\n<% /*classroot(isinteraction) ::= <<*/ %>\n\n/*\n * Copyright (c) 2008, Institute for Software Integrated Systems, Vanderbilt University\n * All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this software and its\n * documentation for any purpose, without fee, and without written agreement is\n * hereby granted, provided that the above copyright notice, the following\n * two paragraphs and the author appear in all copies of this software.\n *\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n */\n\n#include <boost/lexical_cast.hpp>\n#include \"<%=isinteraction?\"Interaction\":\"Object\"%>Root.hpp\"\n\nC2WLogger* <%=isinteraction?\"Interaction\":\"Object\"%>Root::_logger = &C2W_RTI_LOGGER_CLS::get_singleton();\n\n<% /*classcommon(classname=apMap.classfirstupper+\"Root\",hlaclassname=apMap.classfirstupper+\"Root\",...)*/ %>\n<%- ejs.render(TEMPLATES[\"cpp/classcommon.cpp.ejs\"],\n\t{\tisinteraction: isinteraction,\n\t\tclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\n\t\tparentclassname: \"\",\n\t\thlaclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\n\t\tdatamembers: [],\n\t\talldatamembers: []\n}) %>\n\n<% if(!isinteraction){ %>\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::publish( const std::string &className, const std::string &attributeName ) {\n\tNameStringVectorPtrMap::iterator camItr = getClassNamePublishAttributeNameVectorPtrMap().find( className );\n\tif ( camItr == getClassNamePublishAttributeNameVectorPtrMap().end() ) {\n\t\tstd::cerr << \"ERROR:  ObjectRoot.publish:  could not publish class \\\"\" << className << \"\\\" \\\"\" << attributeName << \"\\\" attribute.\" << std::endl;\n\t\treturn;\n\t}\n\tNameStringVectorPtrMap::iterator dnsItr = getAllDatamemberClassNameVectorPtrMap().find( className );\n\tif ( dnsItr == getAllDatamemberClassNameVectorPtrMap().end() ) {\n\t\tstd::cerr << \"ERROR:  ObjectRoot.publish:  unexpected error:  no datamember vector for class \\\"\" << className << \"\\\"\" << std::endl;\n\t\treturn;\n\t}\n\tif (  std::find ( dnsItr->second->begin(), dnsItr->second->end(), attributeName ) == dnsItr->second->end()  ) {\n\t\tstd::cerr << \"ERROR:  ObjectRoot.publish:  no datamember named \\\"\" << attributeName << \"\\\" in class \\\"\" << className << \"\\\"\" << std::endl;\n\t\treturn;\n\t}\n\tcamItr->second->push_back( attributeName );\n}\n\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::subscribe( const std::string &className, const std::string &attributeName ) {\n\tNameStringVectorPtrMap::iterator camItr = getClassNameSubscribeAttributeNameVectorPtrMap().find( className );\n\tif ( camItr == getClassNameSubscribeAttributeNameVectorPtrMap().end() ) {\n\t\tstd::cerr << \"ERROR:  ObjectRoot.subscribe:  could not subscribe class \\\"\" << className << \"\\\" \\\"\" << attributeName << \"\\\" attribute.\" << std::endl;\n\t\treturn;\n\t}\n\tNameStringVectorPtrMap::iterator dnsItr = getAllDatamemberClassNameVectorPtrMap().find( className );\n\tif ( dnsItr == getAllDatamemberClassNameVectorPtrMap().end() ) {\n\t\tstd::cerr << \"ERROR:  ObjectRoot.subscribe:  unexpected error:  no datamember vector for class \\\"\" << className << \"\\\"\" << std::endl;\n\t\treturn;\n\t}\n\tif (  std::find ( dnsItr->second->begin(), dnsItr->second->end(), attributeName ) == dnsItr->second->end()  ) {\n\t\tstd::cerr << \"ERROR:  ObjectRoot.subscribe:  no datamember named \\\"\" << attributeName << \"\\\" in class \\\"\" << className << \"\\\"\" << std::endl;\n\t\treturn;\n\t}\n\tcamItr->second->push_back( attributeName );\n}\n\n<%}%>\n\t\n<%=isinteraction?\"Interaction\":\"Object\"%>Root::SP <%=isinteraction?\"Interaction\":\"Object\"%>Root::create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap ) {\n\tIntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );\n\tif ( ismItr == getClassHandleNameMap().end() ) {\n\t\treturn SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 );\n\t}\n\t\n\tClassNameFactoryMap::iterator cfmItr = getClassNameFactoryMap().find( ismItr->second );\n\tif ( cfmItr == getClassNameFactoryMap().end() ) {\n\t\treturn SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 );\n\t}\n\t\n\tSP sp = (*cfmItr->second)();\n\tsp->set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\n\n\treturn sp;\n}\n\n<%=isinteraction?\"Interaction\":\"Object\"%>Root::SP <%=isinteraction?\"Interaction\":\"Object\"%>Root::create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap, const RTIfedTime &dlc13FedTime ) {\n\tIntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );\n\tif ( ismItr == getClassHandleNameMap().end() ) {\n\t\treturn SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 );\n\t}\n\t\n\tClassNameFactoryMap::iterator cfmItr = getClassNameFactoryMap().find( ismItr->second );\n\tif ( cfmItr == getClassNameFactoryMap().end() ) {\n\t\treturn SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 );\n\t}\n\t\n\tSP sp = (*cfmItr->second)();\n\tsp->set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\n\tsp->setTime( dlc13FedTime.getTime() );\n\n\treturn sp;\n}\n\n\n<% if(!isinteraction){ %>\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::requestUpdate( RTI::RTIambassador *rti ) {\n\tbool requestNotSubmitted = true;\n\twhile( requestNotSubmitted ) {\n\t\ttry {\t\t\n\t\t\trti->requestObjectAttributeValueUpdate( getObjectHandle(), getSubscribedAttributeHandleSet_var() );\n\t\t\trequestNotSubmitted = false;\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\n\t\t\tstd::cerr << \"ERROR: \" << getClassName() << \"request for update failed:  Federate Not Execution Member\" << std::endl;\n\t\t\treturn;\t\t\t\t\n\t\t} catch ( RTI::ObjectNotKnown & ) {\n\t\t\tstd::cerr << \"ERROR: \" << getClassName() << \"request for update failed:  Object Not Known\" << std::endl;\n\t\t\treturn;\t\t\t\t\n\t\t} catch ( RTI::AttributeNotDefined & ) {\n\t\t\tstd::cerr << \"ERROR: \" << getClassName() << \"request for update failed:  Name Not Found\" << std::endl;\n\t\t\treturn;\t\t\t\t\n\t\t} catch ( ... ) {\n\t\t\tstd::cerr << \"ERROR: \" << getClassName() << \"request for update failed:  Unknown Exception\" << std::endl;\t\t\t}\n\t}\n}\n\n<%}%>\n\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap ) {\n\tint size = datamemberMap.size();\n\tfor( int ix = 0 ; ix < size ; ++ix ) {\n\t\ttry {\n\t\t\tstatic RTI::ULong valueLength;\n\t\t\tchar *value = datamemberMap.getValuePointer( ix, valueLength );\n\t\t\tset<%=isinteraction?\"Parameter\":\"Attribute\"%>(  datamemberMap.getHandle( ix ), std::string( value, valueLength )  );\n\t\t} catch ( ... ) {\n\t\t\tstd::cerr << \"set<%=isinteraction?\"Parameter\":\"Attribute\"%>s: Exception caught!\" << std::endl;\n\t\t}\n\t}\n}\n\n<% if(isinteraction){ %>\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::sendInteraction( RTI::RTIambassador *rti, double time ) {\n\tbool interactionNotSent = true;\n\twhile( interactionNotSent ) {\n\t\ttry {\n\t\t\tParameterHandleValuePairSetSP datamembers = createDatamemberHandleValuePairSet( 0 );\n\t\t\trti->sendInteraction(  getClassHandle(), *datamembers, RTIfedTime( time ), 0  );\n\t\t\tcreateLog( time, true );\n\t\t\tinteractionNotSent = false;\n\t\t} catch ( RTI::InteractionClassNotDefined & ) {\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Class Not Defined\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::InteractionClassNotPublished & ) {\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Class Not Published\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::InteractionParameterNotDefined & ) {\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Parameter Not Defined\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::InvalidFederationTime & ) {\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Invalid Federation Time\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Federate Not Execution Member\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::ConcurrentAccessAttempted & ) {\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  ConcurrentAccessAttempted\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( ... ) {\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Exception caught ... retry\" << std::endl;\n#ifdef _WIN32\n\t\t\tSleep( 500 );\n#else\n\t\t\tusleep( 500000 );\n#endif\n\t\t}\n\t}\n}\n\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::sendInteraction( RTI::RTIambassador *rti ) {\n\tbool interactionNotSent = true;\n\twhile( interactionNotSent ) {\n\t\ttry {\n\t\t\tParameterHandleValuePairSetSP datamembers = createDatamemberHandleValuePairSet( 0 );\n\t\t\trti->sendInteraction(  getClassHandle(), *datamembers, 0  );\n\t\t\tcreateLog( 0, true );\n\t\t} catch ( RTI::InteractionClassNotDefined & ) {\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Class Not Defined\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::InteractionClassNotPublished & ) {\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Class Not Published\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::InteractionParameterNotDefined & ) {\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Parameter Not Defined\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Federate Not Execution Member\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::ConcurrentAccessAttempted & ) {\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  ConcurrentAccessAttempted\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( ... ) {\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Exception caught ... retry\" << std::endl;\n#ifdef _WIN32\n\t\t\tSleep( 500 );\n#else\n\t\t\tusleep( 500000 );\n#endif\n\t\t}\n\t}\n}\n\nstd::string <%=isinteraction?\"Interaction\":\"Object\"%>Root::fedName = \"\";\nbool <%=isinteraction?\"Interaction\":\"Object\"%>Root::enablePubLog = false;\nbool <%=isinteraction?\"Interaction\":\"Object\"%>Root::enableSubLog = false;\nstd::string <%=isinteraction?\"Interaction\":\"Object\"%>Root::pubLogLevel = \"\";\nstd::string <%=isinteraction?\"Interaction\":\"Object\"%>Root::subLogLevel = \"\";\n\nvoid InteractionRoot::enablePublishLog( const std::string &interaction, const std::string &fed, const std::string &thislevel, const std::string &globallevel ) {\n\tif ( globallevel.empty() ) {\n\t\treturn;\n\t}\n\tif (  _logger->getLogLevel( thislevel ) > _logger->getLogLevel( globallevel )  ) {\n\t\treturn;\n\t}\n\tfedName = fed;\n\tenablePubLog = true;\n\tpubLogLevel = thislevel;\n\t_logger->addLog(interaction, fedName, true);\n}\n\nvoid InteractionRoot::enableSubscribeLog( const std::string &interaction, const std::string &fed, const std::string &thislevel, const std::string &globallevel ) {\n\tif ( globallevel.empty() ) {\n\t\treturn;\n\t}\n\tif (  _logger->getLogLevel( thislevel ) > _logger->getLogLevel( globallevel )  ) {\n\t\treturn;\n\t}\n\tfedName = fed;\n\tenableSubLog = true;\n\tsubLogLevel = thislevel;\n\t_logger->addLog( interaction, fedName, false );\n}\n\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::createLog( double time, bool isPub ) {\n\tif (  ( isPub && !enablePubLog ) || ( !isPub && !enableSubLog )  ) {\n\t\treturn;\n\t}\n\n\tstd::string interactionId;\n\tif ( isPub ) {\n\t\tinteractionId = \"pub_\" + getClassName();\n\t\tif ( !fedName.empty() ) {\n\t\t\tinteractionId = fedName + \"_\" + interactionId;\n\t\t}\n\t} else {\n\t\tinteractionId = getClassName() + \"_sub\";\n\t\tif ( !fedName.empty() ) {\n\t\t\tinteractionId += \"_\" + fedName;\n\t\t}\n\t}\n\t\n\t_logger->addLog( interactionId, *this, time, pubLogLevel );\n}\n\n<%}else{%>\nvoid ObjectRoot::registerObject( RTI::RTIambassador *rti ) {\n    \n    while( !_isRegistered ) {\n        try {\n            _object_handle = rti->registerObjectInstance( getClassHandle() );\n            _isRegistered = true;\n        } catch ( RTI::ObjectClassNotDefined & ) {\n        \tstd::cerr << \"ERROR:  InteractionRoot::registerObject:  Object Class Not Defined\" << std::endl;\n            return;\n        } catch ( RTI::ObjectClassNotPublished & ) {\n        \tstd::cerr << \"ERROR:  InteractionRoot::registerObject:  Object Class Not Published\" << std::endl;\n            return;\n        } catch ( RTI::FederateNotExecutionMember & ) {\n        \tstd::cerr << \"ERROR:  InteractionRoot::registerObject:  Federate Not Execution Member\" << std::endl;\n            return;\n        } catch ( ... ) {\n        \tstd::cerr << \"InteractionRoot::registerObject:  Exception caught ... retry\" << std::endl;\n        }\n    }\n\n}\n\nvoid ObjectRoot::unregisterObject( RTI::RTIambassador *rti ) {\n    \n    while( _isRegistered ) {\n        try {\n            rti->deleteObjectInstance( getObjectHandle(), 0 );\n            _isRegistered = false;\n        } catch ( RTI::ObjectNotKnown & ) {\n        \tstd::cerr << \"ERROR:  InteractionRoot::unregisterObject:  Object Not Known\" << std::endl;\n            return;\n        } catch ( RTI::DeletePrivilegeNotHeld & ) {\n        \tstd::cerr << \"ERROR:  InteractionRoot::unregisterObject:  Delete Privilege Not Held\" << std::endl;\n            return;\n        } catch ( RTI::FederateNotExecutionMember & ) {\n        \tstd::cerr << \"ERROR:  InteractionRoot::unregisterObject:  Federate Not Execution Member\" << std::endl;\n            return;\n        } catch ( ... ) {\n        \tstd::cerr << \"InteractionRoot::unregisterObject:  Exception caught ... retry\" << std::endl;\n        }\n    }\n}\n\nvoid ObjectRoot::updateAttributeValues( RTI::RTIambassador *rti, double time, bool force ) {\n\n    AttributeHandleValuePairSetSP suppliedAttributesSP = createDatamemberHandleValuePairSet( force );\n    if ( suppliedAttributesSP->size() == 0 ) {\n    \treturn;\n    }\n\n    try {\n        rti->updateAttributeValues(  getObjectHandle(), *suppliedAttributesSP, RTIfedTime( time ), 0  );\n        createLog( time, true );\n    } catch ( RTI::ObjectNotKnown & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Object Not Known\" << std::endl;\n        return;\n    } catch ( RTI::FederateNotExecutionMember & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Federate Not Execution Member\" << std::endl;\n        return;\n    } catch ( RTI::AttributeNotDefined & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Attribute Not Defined\" << std::endl;\n        return;\n    } catch ( RTI::AttributeNotOwned & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Attribute Not Owned\" << std::endl;\n        return;\n    } catch ( RTI::ConcurrentAccessAttempted & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Concurrent Access Attempted\" << std::endl;\n        return;\n    } catch ( RTI::InvalidFederationTime & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Invalid Federation Time\" << std::endl;\n        return;\n    } catch ( ... ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  exception caught\" << std::endl;\n    }\n}\n\nvoid ObjectRoot::updateAttributeValues( RTI::RTIambassador *rti, bool force ) {\n\n    AttributeHandleValuePairSetSP suppliedAttributesSP = createDatamemberHandleValuePairSet( force );\n    if ( suppliedAttributesSP->size() == 0 ) {\n    \treturn;\n    }\n\n    try {\n        rti->updateAttributeValues( getObjectHandle(), *suppliedAttributesSP, 0 );\n        createLog( 0, true );\n    } catch ( RTI::ObjectNotKnown & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Object Not Known\" << std::endl;\n        return;\n    } catch ( RTI::FederateNotExecutionMember & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Federate Not Execution Member\" << std::endl;\n        return;\n    } catch ( RTI::AttributeNotDefined & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Attribute Not Defined\" << std::endl;\n        return;\n    } catch ( RTI::AttributeNotOwned & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Attribute Not Owned\" << std::endl;\n        return;\n    } catch ( RTI::ConcurrentAccessAttempted & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Concurrent Access Attempted\" << std::endl;\n        return;\n    } catch ( RTI::InvalidFederationTime & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Invalid Federation Time\" << std::endl;\n        return;\n    } catch ( ... ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  exception caught\" << std::endl;\n    }\n}\n\nstd::string ObjectRoot::fedName = \"\";\n\nvoid ObjectRoot::enablePublishLog(const std::string &object, const std::string &attribute, const std::string &fed, const std::string &thislevel, const std::string &globallevel) {\n\n\tif ( globallevel.empty() ) {\n\t\treturn;\n\t}\n\tif (  _logger->getLogLevel( thislevel ) > _logger->getLogLevel( globallevel )  ) {\n\t\treturn;\n\t}\n\tfedName = fed;\n\tgetPubAttributeLogMap().insert(  make_pair( attribute, thislevel )  );\n\t_logger->addLog( object, attribute, fed, true );\n}\n\nvoid ObjectRoot::enableSubscribeLog( const std::string &object, const std::string &attribute, const std::string &fed, const std::string &thislevel, const std::string &globallevel ) {\n\tif ( globallevel.empty() ) {\n\t\treturn;\n\t}\n\tif (  _logger->getLogLevel( thislevel ) > _logger->getLogLevel( globallevel )  ) {\n\t\treturn;\n\t}\n\tfedName = fed;\n\tgetSubAttributeLogMap().insert(  make_pair( attribute, thislevel )  );\n\t_logger->addLog( object, attribute, fed, false );\n}\n\nvoid ObjectRoot::createLog( double time, bool isPub ) {\n\n\tif ( getPubAttributeLogMap().empty() ) {\n\t\treturn;\n\t}\n\tstd::string id = isPub ? fedName + \"_pub_\" + getClassName() : getClassName() + \"_sub_\" + fedName;\n\t_logger->addLog( id, *this, time );\n}\n\n<%}%>\n",
    "cpp/classroot.hpp.ejs": "\n<% /* THIS IS THE ROOT CLASS OF EITHER THE INTERACTION OR OBJECT-CLASS HEIRARCHY (I.E. \"InteractionRoot\" OR \"ObjectRoot\") */\n/*classroot(isinteraction) ::= <<*/ %>\n/*\n * Copyright (c) 2008, Institute for Software Integrated Systems, Vanderbilt University\n * All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this software and its\n * documentation for any purpose, without fee, and without written agreement is\n * hereby granted, provided that the above copyright notice, the following\n * two paragraphs and the author appear in all copies of this software.\n *\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n * \n */\n\n/*\n * \tNOTE:  ALL \"if\" STATEMENTS IN THIS CODE THAT HAD THE FORM:\n *\n *  if (condition) statement;\n *\n *\tOR\n *\n *  if (condition) statement1;\n *  else           statement2;\n *\n *  HAVE BEEN CONVERTED TO THE FORMS:\n *\n *  if (condition) {\n *\t\tstatement;\n *\t}\n *\n *\tAND\n *\n *  if (condition) {\n *\t\tstatement1;\n *\t} else {\n *\t\tstatement2;\n *\t}\n *\n *\tRESPECTIVELY.  THIS IS BECAUSE THE OMNET DEBUGGER APPEARS TO HAVE A PROBLEM\n *  WITH THE NON-BRACED FORMS OF THE IF STATEMENT.  *PLEASE* DO NOT CHANGE IT BACK.\n *  -- H.S.N.\n *\n */\n\n<% if(isinteraction){ %>\n#ifndef _INTERACTION_ROOT\n#define _INTERACTION_ROOT\n<% }else{ %>\n#ifndef _OBJECT_ROOT\n#define _OBJECT_ROOT\n<%}%>\n\n#ifndef _CRT_SECURE_NO_DEPRECATE\n#define _CRT_SECURE_NO_DEPRECATE\n#endif\n\n#ifndef RTI_USES_STD_FSTREAM\n#define RTI_USES_STD_FSTREAM\n#endif\n\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <set>\n#include <map>\n#include <list>\n#include <ctype.h>\n#include <stdlib.h>\n\n#include <boost/shared_ptr.hpp>\n\n#include <TypeMedley.hpp>\n#include <StringCollections.hpp>\n\n#include \"RTI.hh\"\n#include \"fedtime.hh\"\n\n#ifdef _WIN32\n#include <windows.h>\n#else\n#include <unistd.h>\n#endif\n\n#include \"RTILogger.hpp\"\n\n#ifndef C2W_RTI_LOGGER_CLS\n#define C2W_RTI_LOGGER_CLS C2WConsoleLogger\n#endif \n\n#include \"<%=isinteraction?\"Interaction\":\"Object\"%>If.hpp\"\n\nclass <%=isinteraction?\"Interaction\":\"Object\"%>Root : public <%=isinteraction?\"Interaction\":\"Object\"%>If{\npublic:\n\ttypedef std::map< std::string, StringSet * > NameStringSetPtrMap;\n\ttypedef std::map< std::string, StringVector * > NameStringVectorPtrMap;\n\ttypedef std::map< std::string, int > StringIntegerMap;\n\ttypedef std::map< int, std::string > IntegerStringMap;\n\n\ttypedef boost::shared_ptr< <%=isinteraction?\"Interaction\":\"Object\"%>Root > SP;\n\ttypedef boost::shared_ptr< RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet > <%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSetSP;\n\t\n\ttypedef SP (*FactoryFunctionPtr)( void );\n\ttypedef std::map< std::string, FactoryFunctionPtr > ClassNameFactoryMap;\n\n\ttypedef void (*PubsubFunctionPtr)( RTI::RTIambassador * );\n\ttypedef std::map< std::string, PubsubFunctionPtr > ClassNamePubSubMap;\n\ttypedef std::map< std::string, std::string> DatamemberTypeMap;\n\t\n\t\n<% if(!isinteraction){ %>\n\ttypedef std::map< std::string, RTI::AttributeHandleSet * > ClassNameAttributesPtrMap;\n\ttypedef std::map< int, SP > ObjectMap;\n<%}%>\n\n\tstatic DatamemberTypeMap &getDatamemberTypeMap( void ) {\n\t\tstatic DatamemberTypeMap datamemberTypeMap;\n\t\treturn datamemberTypeMap;\n\t}\n\nprotected:\n\tstatic StringSet &getClassNameSet( void ) {\n\t\tstatic StringSet classNameSet;\n\t\treturn classNameSet;\n\t}\n\n\tstatic ClassNameFactoryMap &getClassNameFactoryMap( void ) {\n\t\tstatic ClassNameFactoryMap classNameFactoryMap;\n\t\treturn classNameFactoryMap;\n\t}\n\t\n\tstatic ClassNamePubSubMap &getClassNamePublishMap( void ) {\n\t\tstatic ClassNamePubSubMap classNamePublishMap;\n\t\treturn classNamePublishMap;\n\t}\n\n\tstatic ClassNamePubSubMap &getClassNameUnpublishMap( void ) {\n\t\tstatic ClassNamePubSubMap classNameUnpublishMap;\n\t\treturn classNameUnpublishMap;\n\t}\n\n\tstatic ClassNamePubSubMap &getClassNameSubscribeMap( void ) {\n\t\tstatic ClassNamePubSubMap classNameSubscribeMap;\n\t\treturn classNameSubscribeMap;\n\t}\n\n\tstatic ClassNamePubSubMap &getClassNameUnsubscribeMap( void ) {\n\t\tstatic ClassNamePubSubMap classNameUnsubscribeMap;\n\t\treturn classNameUnsubscribeMap;\n\t}\n\n\tstatic NameStringVectorPtrMap &getDatamemberClassNameVectorPtrMap( void ) {\n\t\tstatic NameStringVectorPtrMap datamemberClassNameVectorPtrMap;\n\t\treturn datamemberClassNameVectorPtrMap;\n\t}\n\n\tstatic NameStringVectorPtrMap &getAllDatamemberClassNameVectorPtrMap( void ) {\n\t\tstatic NameStringVectorPtrMap allDatamemberClassNameVectorPtrMap;\n\t\treturn allDatamemberClassNameVectorPtrMap;\n\t}\n\n\tstatic StringIntegerMap &getClassNameHandleMap( void ) {\n\t\tstatic StringIntegerMap classNameHandleMap;\n\t\treturn classNameHandleMap;\n\t}\n\tstatic IntegerStringMap &getClassHandleNameMap( void ) {\n\t\tstatic IntegerStringMap classHandleNameMap;\n\t\treturn classHandleNameMap;\n\t}\n\n\tstatic StringIntegerMap &getDatamemberNameHandleMap( void ) {\n\t\tstatic StringIntegerMap datamemberNameHandleMap;\n\t\treturn datamemberNameHandleMap;\n\t}\n\tstatic IntegerStringMap &getDatamemberHandleNameMap( void ) {\n\t\tstatic IntegerStringMap datamemberHandleNameMap;\n\t\treturn datamemberHandleNameMap;\n\t}\n\n<% if(!isinteraction){ %>\n\tstatic NameStringVectorPtrMap &getClassNamePublishAttributeNameVectorPtrMap( void ) {\n\t\tstatic NameStringVectorPtrMap classNamePublishAttributeNameVectorPtrMap;\n\t\treturn classNamePublishAttributeNameVectorPtrMap;\n\t}\n\tstatic NameStringVectorPtrMap &getClassNameSubscribeAttributeNameVectorPtrMap( void ) {\n\t\tstatic NameStringVectorPtrMap classNameSubscribeAttributeNameVectorPtrMap;\n\t\treturn classNameSubscribeAttributeNameVectorPtrMap;\n\t}\n\t\n\tstatic ClassNameAttributesPtrMap &getClassNamePublishedAttributesPtrMap( void ) {\n\t\tstatic ClassNameAttributesPtrMap classNamePublishedAttributesPtrMap;\n\t\treturn classNamePublishedAttributesPtrMap;\n\t}\n\tstatic ClassNameAttributesPtrMap &getClassNameSubscribedAttributesPtrMap( void ) {\n\t\tstatic ClassNameAttributesPtrMap classNameSubscribedAttributesPtrMap;\n\t\treturn classNameSubscribedAttributesPtrMap;\n\t}\n\n\tstatic ObjectMap &getObjectMap( void ) {\n\t\tstatic ObjectMap objectMap;\n\t\treturn objectMap;\n\t}\n\n\ttemplate< typename S, typename T >\n\tclass Attribute {\n\tprivate:\n\t\tT _value;\n\t\tT _oldValue;\n\t\tbool _oldValueInit;\n\t\tdouble _time;\n\t\n\tpublic:\n\t\t\n\t\tAttribute( void ) : _value( 0 ), _oldValueInit( false ), _time( -1 ) { }\n\t\t\n\t\tT getValue( void ) const { return _value; }\n\t\tvoid setValue( T value ) { _value = value; }\n\t\t\n\t\tdouble getTime( void ) { return _time; }\n\t\tvoid setTime( double time ) { _time = time; }\n\t\t\n\t\tvoid setHasBeenUpdated( void ) {\n\t\t\t_oldValue = _value;\n\t\t\t_oldValueInit = true;\n\t\t}\n\t\t\n\t\tbool shouldBeUpdated( bool force ) { return force || !_oldValueInit || _oldValue != _value; }\n\t};\n\n\ttemplate< typename S >\n\tclass Attribute< S, std::string > {\n\tprivate:\n\t\tstd::string _value;\n\t\tstd::string _oldValue;\n\t\tbool _oldValueInit;\n\t\tdouble _time;\n\t\n\tpublic:\n\t\t\n\t\tAttribute( void ) : _oldValueInit( false ), _time( -1 ) { }\n\t\t\n\t\tconst std::string &getValue( void ) const { return _value; }\n\t\tvoid setValue( const std::string &value ) { _value = value; }\n\t\t\n\t\tdouble getTime( void ) { return _time; }\n\t\tvoid setTime( double time ) { _time = time; }\n\t\t\n\t\tvoid setHasBeenUpdated( void ) {\n\t\t\t_oldValue = _value;\n\t\t\t_oldValueInit = true;\n\t\t}\n\t\t\n\t\tbool shouldBeUpdated( bool force ) { return force || !_oldValueInit || _oldValue != _value; }\n\t};\n\t\n<%}%>\n\t\n<% /*classcommon(classname=apMap.classfirstupper+\"Root\",hlaclassname=apMap.classfirstupper+\"Root\",...)*/ -%>\n<%- ejs.render(\n\tTEMPLATES[\"cpp/classcommon.hpp.ejs\"],{\n\t\tisinteraction: isinteraction,\n\t\tclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\n\t\tparentclassname: \"\",\n\t\thlaclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\n\t\tdatamembers: [],\n\t\talldatamembers: []\n}) %>\npublic:\n\tstatic StringSet get_<%=isinteraction?\"interaction\":\"object\"%>_names( void ) { return getClassNameSet(); }\n\tstatic StringVector get_<%=isinteraction?\"parameter\":\"attribute\"%>_names( const std::string &className ) {\n\t\tNameStringVectorPtrMap::iterator nssItr = getDatamemberClassNameVectorPtrMap().find( className );\n\t\treturn nssItr == getDatamemberClassNameVectorPtrMap().end() ? StringVector() : *nssItr->second;\n\t}\n\t\n\tstatic StringVector get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names( const std::string &className ) {\n\t\tNameStringVectorPtrMap::iterator nssItr = getAllDatamemberClassNameVectorPtrMap().find( className );\n\t\treturn nssItr == getAllDatamemberClassNameVectorPtrMap().end() ? StringVector() : *nssItr->second;\n\t}\n\t\n\tstatic std::string get_class_name( int classHandle ) {\n\t\tIntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );\n\t\treturn ismItr == getClassHandleNameMap().end() ? std::string() : ismItr->second;\n\t}\n\t\n\tstatic int get_handle( const std::string &className ) {\n\t\n\t\tStringIntegerMap::iterator simItr = getClassNameHandleMap().find( className );\n\t\tif ( simItr == getClassNameHandleMap().end() ) {\n\t\t\tstd::cerr << \"Bad class name \\\"\" << className << \"\\\" on get_handle.\" << std::endl;\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\treturn simItr->second;\n\t}\n\t\n\tstatic std::string get_<%=isinteraction?\"parameter\":\"attribute\"%>_name( int datamemberHandle ) {\n\t\tIntegerStringMap::iterator ismItr = getDatamemberHandleNameMap().find( datamemberHandle );\n\t\treturn ismItr == getDatamemberHandleNameMap().end() ? std::string() : ismItr->second;\n\t}\n\t\n\tstatic int get_<%=isinteraction?\"parameter\":\"attribute\"%>_handle( const std::string &className, const std::string &datamemberName ) {\n\t\n\t\tStringIntegerMap::iterator simItr = getDatamemberNameHandleMap().find( className + \".\" + datamemberName );\n\t\tif ( simItr == getDatamemberNameHandleMap().end() ) {\n\t\t\tstd::cerr << \"Bad <%=isinteraction?\"parameter\":\"attribute\"%> \\\"\" << datamemberName << \"\\\" for class \\\"\" << className << \"\\\" on get_<%=isinteraction?\"parameter\":\"attribute\"%>_handle.\" << std::endl;\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\treturn simItr->second;\n\t}\n\t\n\tstatic void publish( const std::string &className, RTI::RTIambassador *rti ) {\n\t\tClassNamePubSubMap::iterator cpmItr = getClassNamePublishMap().find( className );\n\t\tif ( cpmItr == getClassNamePublishMap().end() ) {\n\t\t\tstd::cerr << \"Bad class name \\\"\" << className << \"\\\" on publish.\" << std::endl;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t(*cpmItr->second)( rti );\n\t}\n\t\n\tstatic void unpublish( const std::string &className, RTI::RTIambassador *rti ) {\n\t\tClassNamePubSubMap::iterator cpmItr = getClassNameUnpublishMap().find( className );\n\t\tif ( cpmItr == getClassNameUnpublishMap().end() ) {\n\t\t\tstd::cerr << \"Bad class name \\\"\" << className << \"\\\" on unpublish.\" << std::endl;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t(*cpmItr->second)( rti );\n\t}\n\t\n\tstatic void subscribe( const std::string &className, RTI::RTIambassador *rti ) {\n\t\tClassNamePubSubMap::iterator cpmItr = getClassNameSubscribeMap().find( className );\n\t\tif ( cpmItr == getClassNameSubscribeMap().end() ) {\n\t\t\tstd::cerr << \"Bad class name \\\"\" << className << \"\\\" on subscribe.\" << std::endl;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t(*cpmItr->second)( rti );\n\t}\n\t\n\tstatic void unsubscribe( const std::string &className, RTI::RTIambassador *rti ) {\n\t\tClassNamePubSubMap::iterator cpmItr = getClassNameUnsubscribeMap().find( className );\n\t\tif ( cpmItr == getClassNameSubscribeMap().end() ) {\n\t\t\tstd::cerr << \"Bad class name \\\"\" << className << \"\\\" on unsubscribe.\" << std::endl;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t(*cpmItr->second)( rti );\n\t}\n\n<% if(!isinteraction){ %>\n\tstatic void publish( const std::string &className, const std::string &attributeName );\n\t\n\tstatic void unpublish( const std::string &className, const std::string &attributeName ) {\n\t\tNameStringVectorPtrMap::iterator camItr = getClassNamePublishAttributeNameVectorPtrMap().find( className );\n\t\tif ( camItr == getClassNamePublishAttributeNameVectorPtrMap().end() ) {\n\t\t\tstd::cerr << \"ERROR:  ObjectRoot.unpublish:  could not unpublish class \\\"\" << className << \"\\\" \\\"\" << attributeName << \"\\\" attribute.\" << std::endl;\n\t\t\treturn;\n\t\t}\n\t\tcamItr->second->erase( std::remove( camItr->second->begin(), camItr->second->end(), attributeName ), camItr->second->end() );\n\t}\n\tstatic void subscribe( const std::string &className, const std::string &attributeName );\n\t\n\tstatic void unsubscribe( const std::string &className, const std::string &attributeName ) {\n\t\tNameStringVectorPtrMap::iterator camItr = getClassNameSubscribeAttributeNameVectorPtrMap().find( className );\n\t\tif ( camItr == getClassNameSubscribeAttributeNameVectorPtrMap().end() ) {\n\t\t\tstd::cerr << \"ERROR:  ObjectRoot.unsubscribe:  could not unsubscribe class \\\"\" << className << \"\\\" \\\"\" << attributeName << \"\\\" attribute.\" << std::endl;\n\t\t\treturn;\n\t\t}\n\t\tcamItr->second->erase( std::remove( camItr->second->begin(), camItr->second->end(), attributeName ), camItr->second->end() );\n\t}\n<%}%>\n\t\npublic:\n\tstatic SP create_<%=isinteraction?\"interaction\":\"object\"%>( const std::string &className ) {\n\t\tClassNameFactoryMap::iterator cfmItr = getClassNameFactoryMap().find( className );\n\t\treturn cfmItr == getClassNameFactoryMap().end() ? SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 ) : (*cfmItr->second)();\n\t}\n\n\tstatic SP create_<%=isinteraction?\"interaction\":\"object\"%>( const std::string &className, const RTIfedTime &dlc13FedTime ) {\n\t\tClassNameFactoryMap::iterator cfmItr = getClassNameFactoryMap().find( className );\n\t\tif ( cfmItr == getClassNameFactoryMap().end() ) {\n\t\t\treturn SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 );\n\t\t}\n\t\t\n\t\tSP sp = (*cfmItr->second)();\n\t\tsp->setTime( dlc13FedTime.getTime() );\n\t\treturn sp;\n\t}\n\n\tstatic SP create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle ) {\n\t\tIntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );\n\t\treturn ismItr == getClassHandleNameMap().end() ? SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 ) : create_<%=isinteraction?\"interaction\":\"object\"%>( ismItr->second );\n\t}\n\n\tstatic SP create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, const RTIfedTime &dlc13FedTime ) {\n\t\tIntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );\n\t\treturn ismItr == getClassHandleNameMap().end() ? SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 ) : create_<%=isinteraction?\"interaction\":\"object\"%>( ismItr->second, dlc13FedTime );\n\t}\n\n\tstatic SP create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap );\n\tstatic SP create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap, const RTIfedTime &dlc13FedTime );\n\n\tstatic StringVector get_<%=isinteraction?\"parameter\":\"attribute\"%>_names() {\n\t\treturn StringVector();\n\t}\n\n\tstatic StringVector get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names() {\n\t\treturn StringVector();\n\t}\n\n<% if(!isinteraction){ %>\n    static SP discover( int class_handle, int object_handle ) {\n    \n    \tSP sp = create_object( class_handle );\n    \tif ( sp != 0 ) {\n    \t\tgetObjectMap().insert(  std::make_pair( object_handle, sp )  );\n    \t}\n    \treturn sp;\n    }\n    \n    static SP reflect( int object_handle, const RTI::AttributeHandleValuePairSet &datamemberMap ) {\n    \tObjectMap::iterator obmItr = getObjectMap().find( object_handle );\n    \tif ( obmItr == getObjectMap().end() ) {\n    \t\treturn SP( (ObjectRoot *)0 );\n    \t}\n    \t\n    \tSP sp = obmItr->second;\n    \tsp->setTime( -1 );\n\t\tsp->setAttributes( datamemberMap );\n    \treturn sp;\n    }\n\n    static SP reflect(\n     int object_handle,\n     const RTI::AttributeHandleValuePairSet &datamemberMap,\n     double theTime\n    ) {\n    \tObjectMap::iterator obmItr = getObjectMap().find( object_handle );\n    \tif ( obmItr == getObjectMap().end() ) {\n    \t\treturn SP( (ObjectRoot *)0 );\n    \t}\n    \t\n    \tSP sp = obmItr->second;\n    \tsp->setTime( theTime );\n\t\tsp->setAttributes( datamemberMap );\n    \treturn sp;\n    }\n\n\tvoid requestUpdate( RTI::RTIambassador *rti );\n\n\tstatic SP getObject( int object_handle ) {\n\t\tObjectMap::iterator obmItr = getObjectMap().find( object_handle );\n\t\treturn obmItr == getObjectMap().end() ? SP( (ObjectRoot *)0 ) : obmItr->second;\n\t}\n\t\t    \n    static SP removeObject( int object_handle ) {\n\t\tObjectMap::iterator obmItr = getObjectMap().find( object_handle );\n\t\tif ( obmItr == getObjectMap().end() ) {\n\t\t\treturn SP( (ObjectRoot *)0 );\n\t\t}\n\t\t\n\t\tSP sp = obmItr->second;\n        getObjectMap().erase( obmItr );\n        return sp;\n    }\n    \n\nprivate:\n    int _object_handle;\n\n    void setObjectHandle( int object_handle ) {\n        getObjectMap().erase( object_handle );\n        _object_handle = object_handle;\n        getObjectMap().insert(  std::make_pair( object_handle, this )  );\n    }\n\npublic:\n    int getObjectHandle( void ) const { return _object_handle; }\n\t\n<%}%>\n\nprivate:\n\tdouble _time;\n\tstatic C2WLogger* _logger;\n\npublic:\t\n\tdouble getTime( void ) { return _time; }\n\t\n\tvoid setTime( double time ) { _time = time; }\n\tvoid setTime( const RTIfedTime &dlc13FedTime ) {\n\t\tsetTime( dlc13FedTime.getTime() );\n\t}\n\n\t<%=isinteraction?\"Interaction\":\"Object\"%>Root( void ) : _time( -1 )<% if(!isinteraction){%>, _isRegistered( false )<%}%> { }\n\t\n\t<%=isinteraction?\"Interaction\":\"Object\"%>Root( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap ) : _time( -1 )<% if(!isinteraction){%>, _isRegistered( false )<%}%> {\n\t\tset<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\n\t}\n\n\n\t<%=isinteraction?\"Interaction\":\"Object\"%>Root( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap, const RTIfedTime &dlc13FedTime ) : _time( dlc13FedTime.getTime() )<% if(!isinteraction){%>, _isRegistered( false )<%}%> {\n\t\tset<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\n\t}\n\n\tstatic SP create( void ) { return SP( new <%=isinteraction?\"Interaction\":\"Object\"%>Root ); }\n\tstatic SP create( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap ) { return SP(  new <%=isinteraction?\"Interaction\":\"Object\"%>Root( datamemberMap )  ); }\n\tstatic SP create( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap, const RTIfedTime &dlc13FedTime ) {\n\t\treturn SP(  new <%=isinteraction?\"Interaction\":\"Object\"%>Root( datamemberMap, dlc13FedTime )  );\n\t}\n\t\n\n\tvirtual TypeMedley get<%=isinteraction?\"Parameter\":\"Attribute\"%>( const std::string &datamemberName ) const {\n\t\tthrow std::invalid_argument( getClassName() + \" class has no <%=isinteraction?\"parameter\":\"attribute\"%> named \\\"\" + datamemberName + \"\\\"\" );\n\t}\n\t\t\n\tvirtual TypeMedley get<%=isinteraction?\"Parameter\":\"Attribute\"%>( int datamemberHandle ) const {\n\t\tthrow std::invalid_argument(\n\t\t getClassName() + \" class has no <%=isinteraction?\"parameter\":\"attribute\"%> with handle (\" + boost::lexical_cast< std::string >( datamemberHandle ) + \")\"\n\t\t);\n\t}\n\t\t\n\tvoid set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap );\n\nprivate:\n\tvoid set<%=isinteraction?\"Parameter\":\"Attribute\"%>( RTI::Handle handle, const std::string &val ) {\n\t\tif (  !set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( handle, val )  ) {\n\t\t\tstd::cerr << \"set:  bad <%=isinteraction?\"parameter\":\"attribute\"%> handle in class \\\"\" + getClassName() + \"\\\"\" << std::endl;\n\t\t}\n\t}\n\npublic:\n\tvoid set<%=isinteraction?\"Parameter\":\"Attribute\"%>( const std::string &datamemberName, TypeMedley value ) {\n\t\tif (  !set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( datamemberName, value )  ) {\n\t\t\tstd::cerr << \"Error:  class \\\"\" << getClassName() << \"\\\":  invalid <%=isinteraction?\"parameter\":\"attribute\"%> \\\"\" + datamemberName + \"\\\"\" << std::endl;\n\t\t}\n\t}\n\nprotected:\n\tvirtual bool set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( int param_handle, const std::string &val ) {\n\t\treturn false;\n\t}\n\t\n\tvirtual bool set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( const std::string &datamemberName, const std::string &value ) {\n\t\treturn false;\n\t}\n\n\tvirtual bool set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( const std::string &datamemberName, TypeMedley value ) {\n\t\treturn false;\n\t}\n\n\tvirtual <%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSetSP createDatamemberHandleValuePairSet( RTI::ULong count<% if(!isinteraction){%>, bool force<%}%> ) {\n\t\treturn <%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSetSP(  RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>SetFactory::create( count )  );\n\t}\n\t\n\tvirtual <%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSetSP createDatamemberHandleValuePairSet( <% if(!isinteraction){%>bool force<%}%> ) {\n\t\treturn createDatamemberHandleValuePairSet( <% if(!isinteraction){%>force<%}%> );\n\t}\n\t\n<% if(isinteraction){ %>\npublic:\n\tvoid sendInteraction( RTI::RTIambassador *rti, double time );\n\tvoid sendInteraction( RTI::RTIambassador *rti );\n\nprivate:\n\tstatic std::string fedName;\n\t\npublic:\n\tstatic bool enablePubLog;\n\tstatic bool enableSubLog;\n\tstatic std::string pubLogLevel;\n\tstatic std::string subLogLevel;\t\n\npublic:\n\tstatic void enablePublishLog(const std::string &interaction, const std::string &fed, const std::string &thislevel, const std::string &globallevel);\n\tstatic void enableSubscribeLog(const std::string &interaction, const std::string &fed, const std::string &thislevel, const std::string &globallevel);\n\n\tvoid createLog( double time, bool isPub = true );\n\t\n<% }else{ %>\nprivate:\n    bool _isRegistered;\n\npublic:\n    void registerObject( RTI::RTIambassador *rti );\n\tvoid unregisterObject( RTI::RTIambassador *rti );\n\n    void updateAttributeValues( RTI::RTIambassador *rti, double time, bool force );\n\n    void updateAttributeValues( RTI::RTIambassador *rti, double time ) {\n    \tupdateAttributeValues( rti, time, false );\n    }\n\n    void updateAttributeValues( RTI::RTIambassador *rti, bool force );\n\n\tvoid updateAttributeValues( RTI::RTIambassador *rti ) {\n\t\tupdateAttributeValues( rti, false );\n\t}\n\nprivate:\n\tstatic std::string fedName;\n\t\npublic:\n\tstatic void enablePublishLog(const std::string &object, const std::string &attribute, const std::string &fed, const std::string &thislevel, const std::string &globallevel);\n\tstatic void enableSubscribeLog(const std::string &object, const std::string &attribute, const std::string &fed, const std::string &thislevel, const std::string &globallevel);\n\n\tstatic std::map<std::string, std::string> &getPubAttributeLogMap( void) {\n\t\tstatic std::map<std::string, std::string> pubAttributeLogMap;\n\t\treturn pubAttributeLogMap;\n\t}\n\n\tstatic std::map<std::string, std::string> &getSubAttributeLogMap( void) {\n\t\tstatic std::map<std::string, std::string> subAttributeLogMap;\n\t\treturn subAttributeLogMap;\n\t}\n\n\tvoid createLog( double time, bool isPub = true );\n\t\n<%}%>\n\n};\n\ntypedef <%=isinteraction?\"Interaction\":\"Object\"%>Root::SP <%=isinteraction?\"Interaction\":\"Object\"%>RootSP;\n\nstatic bool call_<%=isinteraction?\"Interaction\":\"Object\"%>Root_static_init = <%=isinteraction?\"Interaction\":\"Object\"%>Root::static_init();\n\nstd::ostream &operator<<( std::ostream &os, <%=isinteraction?\"Interaction\":\"Object\"%>Root::SP entitySP );\nstd::ostream &operator<<( std::ostream &os, const <%=isinteraction?\"Interaction\":\"Object\"%>Root &entity );\n#endif\n",
    "cpp/cppfedbase_pom.xml.ejs": "<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId><%=groupId%></groupId>\n  <artifactId><%=artifactId%></artifactId>\n  <version><%=version%></version>\n  <packaging><%=packaging%></packaging>\n  <name><%=name%></name>\n  <description><%=description%></description>\n\n<% if(projects && projects.length > 0){ %> \n    <modules>\n      <% projects.forEach(function(project){ %>\n      <module><%= project.directory ? project.directory : project.artifactId %></module><%}); %> \n    </modules>  \n<%}%>\n    <properties>\n        <boost.version>1.57.0+nar.10</boost.version>\n        <nar-plugin.version>3.3.0</nar-plugin.version>\n        <compiler-name>g++</compiler-name>\n        <linker-name>g++</linker-name>\n    </properties>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>com.github.maven-nar</groupId>\n                <artifactId>nar-maven-plugin</artifactId>\n                <version>${nar-plugin.version}</version>\n                <extensions>true</extensions>\n                <configuration>\n                    <libraries>\n                        <library> \n                            <type>static</type>\n                        </library>\n                    </libraries>\n                    <cpp>\n                        <name>${compiler-name}</name>\n                        <debug>false</debug>\n                        <includes>\n                            <include>**/*.hpp</include>\n                            <include>**/*.h</include>\n                            <include>**/*.cpp</include>\n                            <include>**/*.c</include>\n                        </includes>\n                        <options combine.children=\"append\">\n                            <!--option>-std=c++11</option-->\n                            <option>-ftemplate-depth-128</option>\n                            <option>-fno-inline</option>\n                            <option>-Wall</option>\n                            <option>-pedantic</option>\n                            <option>-Wno-long-long</option>\n                            <option>-Wno-variadic-macros</option>\n                        </options>\n                        <defines>\n                          <!--define>USE_MYSQL_LOGGING</define-->\n                          <define>RTI_USES_STD_FSTREAM</define>\n                        </defines>\n                        <systemIncludePaths>\n                          <systemIncludePath>${build.BOOST_INC_DIR}</systemIncludePath>\n                          <systemIncludePath>${build.RTI_INC_DIR}</systemIncludePath>\n                        </systemIncludePaths>\n                    </cpp>\n                    <linker>\n                        <name>${linker-name}</name>\n                        <incremental>false</incremental>\n                        <libs>\n                          <lib>\n                            <name>RTI-NG_64d</name>\n                            <type>shared</type>\n                            <directory>${build.RTI_LIB_DIR}</directory>\n                          </lib>\n                          <lib>\n                            <name>FedTime_64d</name>\n                            <type>shared</type>\n                            <directory>${build.RTI_LIB_DIR}</directory>\n                          </lib>\n                          <lib>\n                            <name>boost_thread</name>\n                            <type>shared</type>\n                            <directory>${build.BOOST_LIB_DIR}</directory>\n                          </lib>\n                          <lib>\n                            <name>boost_system</name>\n                            <type>shared</type>\n                            <directory>${build.BOOST_LIB_DIR}</directory>\n                          </lib>\n                          <lib>\n                            <name>mysqlcppconn</name>\n                            <type>shared</type>\n                            <directory>${build.MYSQL_LIB_DIR}</directory>\n                          </lib>\n                          <lib>\n                                <name>jvm</name>\n                                <type>shared</type>\n                                <directory>${build.RTI_LIB_JVM_DIR}</directory>\n                            </lib>\n                        </libs>\n                        \n                    </linker>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n\n\n    <profiles>\n        <profile>\n          <id>include-generated</id>\n          <activation>\n                <activeByDefault>false</activeByDefault>\n            </activation>\n          <modules>\n              <module>HelloWorld_base-cpp</module>   \n          </modules>  \n        </profile>\n\n        <profile>\n            <id>windows-common</id>\n            <activation>\n                <os>\n                    <family>windows</family>\n                </os>\n            </activation>\n            <properties>\n              <build.RTI_LIB_DIR>${env.RTI_LIB_DIR}</build.RTI_LIB_DIR>\n              <build.RTI_INC_DIR>${env.RTI_HOME}/include/hla13</build.RTI_INC_DIR>\n              <build.BOOST_INC_DIR>${env.BOOST_INC_DIR}</build.BOOST_INC_DIR>\n              <build.BOOST_LIB_DIR>${env.BOOST_LIB_DIR}</build.BOOST_LIB_DIR>\n              <build.MYSQL_LIB_DIR>${env.MYSQL_LIB_DIR}</build.MYSQL_LIB_DIR>\n            </properties>\n            <build>\n                <plugins>\n                    <plugin>\n                        <groupId>com.github.maven-nar</groupId>\n                        <artifactId>nar-maven-plugin</artifactId>\n                        <extensions>true</extensions>\n                        <configuration>\n                            <cpp>\n                                <options combine.children=\"append\">\n                                    <option>-mthreads</option>\n                                </options>\n                            </cpp>\n                        </configuration>\n                    </plugin>\n                </plugins>\n            </build>\n        </profile>\n\n        <profile>\n            <id>linux-common</id>\n            <activation>\n                <os>\n                    <family>linux</family>\n                </os>\n            </activation>\n            <properties>\n              <build.RTI_LIB_JVM_DIR>${env.RTI_HOME}/jre/lib/amd64/server</build.RTI_LIB_JVM_DIR>\n              <build.RTI_LIB_DIR>${env.RTI_HOME}/lib/gcc4</build.RTI_LIB_DIR>\n              <build.RTI_INC_DIR>${env.RTI_HOME}/include/hla13</build.RTI_INC_DIR>\n              <build.BOOST_INC_DIR>/usr/include/boost</build.BOOST_INC_DIR>\n              <build.BOOST_LIB_DIR>/usr/lib/x86_64-linux-gnu</build.BOOST_LIB_DIR>\n              <build.MYSQL_LIB_DIR>/usr/lib/</build.MYSQL_LIB_DIR>\n            </properties>\n            <build>\n                <plugins>\n                    <plugin>\n                        <groupId>com.github.maven-nar</groupId>\n                        <artifactId>nar-maven-plugin</artifactId>\n                        <extensions>true</extensions>\n                        <configuration>\n                            <cpp>\n                                <options combine.children=\"append\">\n                                    <option>-pthread</option>\n                                </options>\n                            </cpp>\n                        </configuration>\n                    </plugin>\n                </plugins>\n            </build>\n        </profile>\n\n        <profile>\n            <id>mac-common</id>\n            <activation>\n                <os>\n                    <family>mac</family>\n                </os>\n            </activation>\n            <properties>\n              <build.RTI_LIB_DIR>${env.RTI_LIB_DIR}</build.RTI_LIB_DIR>\n              <build.RTI_INC_DIR>${env.RTI_HOME}/include/hla13</build.RTI_INC_DIR>\n              <build.BOOST_INC_DIR>${env.BOOST_INC_DIR}</build.BOOST_INC_DIR>\n              <build.BOOST_LIB_DIR>${env.BOOST_LIB_DIR}</build.BOOST_LIB_DIR>\n              <build.MYSQL_LIB_DIR>${env.MYSQL_LIB_DIR}</build.MYSQL_LIB_DIR>\n            </properties>\n            <build>\n                <plugins>\n                    <plugin>\n                        <groupId>com.github.maven-nar</groupId>\n                        <artifactId>nar-maven-plugin</artifactId>\n                        <extensions>true</extensions>\n                        <configuration>\n                            <cpp>\n                                <options combine.children=\"append\">\n                                    <option>-pthread</option>\n                                </options>\n                            </cpp>\n                        </configuration>\n                    </plugin>\n                </plugins>\n            </build>\n        </profile>\n    </profiles>\n  \n</project>\n",
    "cpp/federate.hpp.ejs": "<%/* group cppfederate;\n\nfederate(\n\tsimname,\n\tclassname,\n\tisnonmapperfed,\n\ttimeconstrained,\n\ttimeregulating,\n\tlookahead,\n\tasynchronousdelivery,\n\tallinteractiondata,\n\tpublishedinteractiondata,\n\tsubscribedinteractiondata,\n\tallobjectdata,\n\tpublishedobjectdata,\n\tsubscribedobjectdata\n) ::= <<\n*/ -%>\n#ifndef _<%=classname%>Base_\n#define _<%=classname%>Base_\n\n#include <vector>\n\n#include \"SynchronizedFederate.hpp\"\n#include \"SubscribedInteractionFilter.hpp\"\n\n<% allinteractiondata.forEach(function(interactiondata){ %>\n#include \"<%=interactiondata.name%>.hpp\"<%});%>\n<% allobjectdata.forEach(function(interactiondata){ %>\n#include \"<%=interactiondata.name%>.hpp\"<%});%>\n#include \"C2WLogger.hpp\"\n\n#include \"FederateConfig.h\"\n\nclass <%=classname%>Base : public SynchronizedFederate {\n\npublic:\n\ttypedef SynchronizedFederate Super;\n\t\n\n\ttypedef std::vector< std::string > ArgVector;\n\t\n\tstatic double getLookAhead( void ) {\n\t\tstatic double lookAhead = <%=lookahead%>;\n\t\treturn lookAhead;\n\t}\n\n\tvirtual ~<%=classname%>Base( void )\n\t throw (RTI::FederateInternalError) { }\n\nprivate:\n\tSubscribedInteractionFilter _subscribedInteractionFilter;\n\nprotected:\n\tvoid init() {\n\n\t\tcreateRTI();\n\t\tjoinFederation();\n\t\t\n\t\t\t\t\t\n<% if(timeconstrained){ %>\n\t\tenableTimeConstrained();\n<%}%>\n\n<% if(timeregulating){ %>\n\t\tenableTimeRegulation( getLookAhead() );\n<%}%>\n\n<% if(asynchronousdelivery){ %>\n\t\tenableAsynchronousDelivery();\n<%}%>\n\n\n        // interaction pubsub\n        <% /*publishedinteractiondata:pubinter()*/ %>\n        <% publishedinteractiondata.forEach(function(interactiondata){ %>\n        <%=interactiondata.name%>::publish( getRTI() );<%});%>\n        <% /*subscribedinteractiondata:subinter()*/ %>  \n        <% subscribedinteractiondata.forEach(function(interactiondata){ %>  \n        <%=interactiondata.name%>::subscribe( getRTI() );\n\t\t_subscribedInteractionFilter.setFedFilters( <%=interactiondata.name%>::get_handle(), SubscribedInteractionFilter::<%=interactiondata.originFedFilter()%>, SubscribedInteractionFilter::<%=interactiondata.srcFedFilter()%> );<%});%>  \n\t\t\n\t\t// object pubsub\n        <% /*publishedobjectdata:pubobjectdata()*/ %>\n        <% publishedobjectdata.forEach(function(objectdata){ %>\n        <% objectdata.publishedAttributeData.forEach(function(attributedata){ %>\n        <%=objectdata.name%>::publish_<%=attributedata.name%>();<%});%>  \n        <%=objectdata.name%>::publish( getRTI() );<%});%>  \n\n        <% /*subscribedobjectdata:subobjectdata()*/ %> \n        <% subscribedobjectdata.forEach(function(objectdata){ %>\n        <% objectdata.subscribedAttributeData.forEach(function(attributedata){ %>\n        <%=objectdata.name%>::subscribe_<%=attributedata.name%>();<%});%> \n        <%=objectdata.name%>::subscribe( getRTI() );<%});%>  \n   \n        \n         // enable pubsub log\n         \n\n\t}\n\npublic:\t\n\t// constructor\t\n\t<%=classname%>Base(FederateConfig *fedconfig): Super(fedconfig) { init(); }\n\n\n\n\t<% /*publishedinteractiondata:create_interaction()*/ %>\n\t<% publishedinteractiondata.forEach(function(interactiondata){ %>\n\t<%=interactiondata.name%>SP create_<%=interactiondata.name%>( void ) {\n\t   <%=interactiondata.name%>SP interactionSP = <%=interactiondata.name%>::create();\n\t   interactionSP->set_sourceFed( getFederateId() );\n\t   interactionSP->set_originFed( getFederateId() );\n\t   return interactionSP;\n\t}<%});%>  \n\n    <% /*filter_interaction()*/ %>\n    virtual void receiveInteraction(\n\t RTI::InteractionClassHandle theInteraction,\n\t const RTI::ParameterHandleValuePairSet& theParameters,\n\t const RTI::FedTime& theTime,\n\t const char *theTag,\n\t RTI::EventRetractionHandle theHandle\n\t)\n\t throw ( RTI::InteractionClassNotKnown, RTI::InteractionParameterNotKnown, RTI::InvalidFederationTime, RTI::FederateInternalError) {\n\n\t\tif ( getMoreATRs() ) {\n\t\t\tInteractionRoot::SP interactionRootSP = InteractionRoot::create_interaction( theInteraction, theParameters, theTime );\n\t\t\tC2WInteractionRootSP c2wInteractionRootSP = boost::dynamic_pointer_cast< C2WInteractionRoot >( interactionRootSP );\n\t\t\tif ( c2wInteractionRootSP != 0 ) {\n\n\t            // Filter interaction if src/origin fed requirements (if any) are not met\n\t            if (  _subscribedInteractionFilter.filterC2WInteraction( getFederateId(), c2wInteractionRootSP )  ) {\n\t            \treturn;\n\t            }\n\t        }\n\n\t        Super::receiveInteraction( theInteraction, theParameters, theTime, theTag, theHandle );\n\t    }\n\t}\n\n\tvirtual void receiveInteraction(\n\t RTI::InteractionClassHandle theInteraction,\n\t const RTI::ParameterHandleValuePairSet& theParameters,\n\t const char *theTag\n\t)\n\t throw ( RTI::InteractionClassNotKnown, RTI::InteractionParameterNotKnown, RTI::FederateInternalError) {\n\t\tif ( getMoreATRs() ) {\n\t\t\tInteractionRoot::SP interactionRootSP = InteractionRoot::create_interaction( theInteraction, theParameters );\n\t\t\tC2WInteractionRootSP c2wInteractionRootSP = boost::dynamic_pointer_cast< C2WInteractionRoot >( interactionRootSP );\n\t\t\tif ( c2wInteractionRootSP != 0 ) {\n\n\t            // Filter interaction if src/origin fed requirements (if any) are not met\n\t            if (  _subscribedInteractionFilter.filterC2WInteraction( getFederateId(), c2wInteractionRootSP )  ) {\n\t            \treturn;\n\t            }\n\t        }\n\n\t\t\tSuper::receiveInteraction( theInteraction, theParameters, theTag );\n\t\t}\n\t}\n};\n\n#endif\n\n",
    "cpp/federate_ver.cpp.ejs": "#include <string>\n\nstatic const std::string _<%=simname%>_base_version_ = \"<%=version%>\";",
    "cpp/federateimpl.cpp.ejs": "<% /* federateimpl(classname) */ -%>\n#include \"<%=classname%>.hpp\"\n\nvoid <%=classname%>::initialize( void ) {\n    m_currentTime = 0;\n    \n    if (this->get_IsLateJoiner()) {\n        m_currentTime = getLBTS() - getLookAhead();\n        disableTimeRegulation();\n    }\n\n    <%=classname%>ATRCallback advanceTimeRequest(*this);\n    putAdvanceTimeRequest(m_currentTime, advanceTimeRequest);\n\n    if(!this->get_IsLateJoiner()){\n        readyToPopulate();\n<% if (publishedobjectdata.length > 0) { -%>\n        initObjectInstances();\n<% } -%>\n        readyToRun();\n    }\n<% if (publishedobjectdata.length > 0) { -%>\n    else {\n        initObjectInstances();\n    }\n<% } -%>\n}\n<% if (publishedobjectdata.length > 0) { -%>\n\nvoid <%=classname%>::initObjectInstances() {\n    // TODO register object instances and send initial values\n<% publishedobjectdata.forEach(function(object_data) { -%>\n    // v<%=object_data.name%>.registerObject(getRTI());\n<% }) -%>\n}\n<% } -%>\n<% if (subscribedobjectdata.length + subscribedinteractiondata.length > 0) { -%>\n\nvoid <%=classname%>::checkReceivedSubscriptions() {\n<% if (subscribedobjectdata.length > 0) { -%>\n\n    SynchronizedFederate::ObjectReflector objectReflector;\n    while(!(objectReflector = getNextObjectReflector()).isNull()) {\n        objectReflector.reflect();\n\n<% (subscribedobjectdata.sort(function(a, b){return b.fullName.length-a.fullName.length})).forEach(function(object_data){ -%>\n        boost::shared_ptr<<%=object_data.name%>> <%=object_data.name.toLowerCase()%>_ptr =\n                boost::dynamic_pointer_cast<<%=object_data.name%>>(objectReflector.getObjectRootSP());\n        if (<%=object_data.name.toLowerCase()%>_ptr != NULL) {\n            handleObjectClass(<%=object_data.name.toLowerCase()%>_ptr);\n            continue;\n        }\n<% }) -%>\n        std::cerr << \"unhandled object reflection \" << objectReflector.getObjectRootSP()->getClassName() << std::endl;\n    }\n<% } -%>\n<% if (subscribedinteractiondata.length > 0) { -%>\n\n    InteractionRoot::SP interactionRootSP;\n    while((interactionRootSP = getNextInteraction()) != 0) {\n<% (subscribedinteractiondata.sort(function(a, b){return b.fullName.length-a.fullName.length})).forEach(function(interaction_data){ -%>\n        boost::shared_ptr<<%=interaction_data.name%>> <%=interaction_data.name.toLowerCase()%>_ptr =\n                boost::dynamic_pointer_cast<<%=interaction_data.name%>>(interactionRootSP);\n        if (<%=interaction_data.name.toLowerCase()%>_ptr != NULL) {\n            handleInteractionClass(<%=interaction_data.name.toLowerCase()%>_ptr);\n            continue;\n        }\n<% }) -%>\n        std::cerr << \"unhandled interaction \" << interactionRootSP->getClassName() << std::endl;\n    }\n<% } -%>\n}\n<% } -%>\n\nvoid <%=classname%>::execute( void ) {\n<% if (subscribedobjectdata.length + subscribedinteractiondata.length > 0) { -%>\n    checkReceivedSubscriptions();\n<% } -%>\n<% if (publishedobjectdata.length > 0) { -%>\n\n    // TODO update registered object instances\n<% publishedobjectdata.forEach(function(object_data) { -%>\n\n<% object_data.parameters.forEach(function(parameter) { -%>\n    // v<%=object_data.name%>.set_<%=parameter.name%>(YOUR_VALUE_HERE);\n<% }) -%>\n    // v<%=object_data.name%>.updateAttributeValues(getRTI(), m_currentTime + getLookAhead());\n<% }) -%>\n<% } -%>\n<% if (publishedinteractiondata.length > 0) { -%>\n\n    // TODO send interactions\n<% publishedinteractiondata.forEach(function(interaction_data) { -%>\n\n    // <%=interaction_data.name%>SP v<%=interaction_data.name%> = create_<%=interaction_data.name%>();\n<% interaction_data.parameters.forEach(function(parameter) { -%>\n    // v<%=interaction_data.name%>->set_<%=parameter.name%>(YOUR_VALUE_HERE);\n<% }) -%>\n    // v<%=interaction_data.name%>->sendInteraction(getRTI(), m_currentTime + getLookAhead());\n<% }) -%>\n<% } -%>\n    \n    m_currentTime += 1;\n    <%=classname%>ATRCallback advanceTimeRequest(*this);\n    putAdvanceTimeRequest(m_currentTime, advanceTimeRequest);\n}\n<% subscribedobjectdata.forEach(function(object_data) { -%>\n\nvoid <%=classname%>::handleObjectClass(boost::shared_ptr<<%=object_data.name%>> object) {\n    // TODO implement how to handle received object update\n}\n<% }); -%>\n<% subscribedinteractiondata.forEach(function(interaction_data) { -%>\n\nvoid <%=classname%>::handleInteractionClass(boost::shared_ptr<<%=interaction_data.name%>> interaction) {\n    // TODO implement how to handle received interaction\n}\n<% }); -%>\n\nint main(int argc, char *argv[]) {\n    FederateConfigParser *configParser = new FederateConfigParser();\n    FederateConfig *config = configParser->parseArgs(argc, argv);\n\n    std::cout << \"Creating <%=classname%> instance\" << std::endl;\n    <%=classname%> federateInstance(config);\n    federateInstance.initialize();\n    std::cout << \"Running <%=classname%> instance\" << std::endl;\n    federateInstance.run();\n\n    return 0;\n}\n",
    "cpp/federateimpl.hpp.ejs": "<% /* federateimpl(classname) */ -%>\n#ifndef _<%=classname.toUpperCase()%>_CLASS\n#define _<%=classname.toUpperCase()%>_CLASS\n\n#include \"<%=classname%>Base.hpp\"\n#include \"FederateConfigParser.h\"\n#include \"FederateConfig.h\"\n\n\nclass <%=classname%> : public <%=classname%>Base {\n    private:\n        double m_currentTime;\n<% if (publishedobjectdata.length > 0) { -%>\n\n        // TODO declare all the published object instances\n<% publishedobjectdata.forEach(function(object_data) { -%>\n        // <%=object_data.name%> v<%=object_data.name%>;\n<% }) -%>\n\n        void initObjectInstances();\n<%} -%>\n<% subscribedobjectdata.forEach(function(object_data) { -%>\n\n        void handleObjectClass(boost::shared_ptr<<%=object_data.name%>> object);\n<% }); -%>\n<% subscribedinteractiondata.forEach(function(interaction_data) { -%>\n\n        void handleInteractionClass(boost::shared_ptr<<%=interaction_data.name%>> interaction);\n<% }); -%>\n\n<% if (subscribedobjectdata.length + subscribedinteractiondata.length > 0) { -%>\n        void checkReceivedSubscriptions();\n\n<% } -%>\n    public:\n        typedef <%=classname%>Base Super;\n\n        <%=classname%>(FederateConfig *configuration): Super(configuration) {}\n\n        virtual ~<%=classname%>( void ) throw (RTI::FederateInternalError) {}\n\n        class <%=classname%>ATRCallback : public ATRCallback {\n            private:\n                <%=classname%> &m_federateInstance;\n            public:\n                <%=classname%>ATRCallback(<%=classname%> &federateInstance): m_federateInstance(federateInstance) {}\n                \n                virtual void execute( void ) {\n                    m_federateInstance.execute();\n                }\n\n                virtual SP clone( void ) {\n                    return SP(new <%=classname%>ATRCallback(*this));\n                }\n        };\n\n        void initialize( void );\n        void execute( void );\n};\n\n#endif\n",
    "cpp/omnetfilter.cpp.ejs": "<% /*FilterInitSource( projectname, subscribedinteractiondata ) ::= << */ %>\n/*\n * Copyright (c) 2016, Institute for Software Integrated Systems, Vanderbilt University\n * All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this software and its\n * documentation for any purpose, without fee, and without written agreement is\n * hereby granted, provided that the above copyright notice, the following\n * two paragraphs and the author appear in all copies of this software.\n *\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n * @author Himanshu Neema\n */\n\n#include \"<%=projectname%>FilterInit.h\"\n#include \"OmnetFOMInteractions.h\"\n//#include \"<%=projectname%>NonOmnetNonGenericSources.hpp\"\n\nvoid <%=projectname%>FilterInit::execute( SubscribedInteractionFilter &subscribedInteractionFilter ) {\n\t<% /*subscribedinteractiondata:initInteractionFilter()*/ %>\n\t<% subscribedinteractiondata.forEach(function(subscribedinteractiondata){%>\n\tsubscribedInteractionFilter.setFedFilters( <%=subscribedinteractiondata.name%>::get_handle(), SubscribedInteractionFilter::<%=subscribedinteractiondata.originFedFilter()%>, SubscribedInteractionFilter::<%=subscribedinteractiondata.srcFedFilter()%> );<%});%>\n\n}\n\nstatic bool init( void ) {\n    SubscribedInteractionFilter::get_singleton().setFilterInit( <%=projectname%>FilterInit::create() );\n    return true;\n}\n\nstatic bool static_init = init();\n\n\n",
    "cpp/omnetfilter.hpp.ejs": "<% /* FilterInitHeader( projectname, subscribedinteractiondata ) ::= << */ %>\n/*\n * Copyright (c) 2016, Institute for Software Integrated Systems, Vanderbilt University\n * All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this software and its\n * documentation for any purpose, without fee, and without written agreement is\n * hereby granted, provided that the above copyright notice, the following\n * two paragraphs and the author appear in all copies of this software.\n *\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n * @author Himanshu Neema\n */\n#ifndef _ISIS_<%=projectname%>_H_\n#define _ISIS_<%=projectname%>_H_\n\n#include \"SubscribedInteractionFilter.hpp\"\n\nstruct <%=projectname%>FilterInit : public SubscribedInteractionFilter::FilterInit {\n    static SP create( void ) { return SP( new <%=projectname%>FilterInit() ); }\n\n    virtual void execute( SubscribedInteractionFilter &subscribedInteractionFilter );\n};\n\n#endif\n",
    "java/class.java.ejs": "<% /*class(isinteraction,simname,classname,parentclassname,hlaclassname,datamembers,alldatamembers,isc2winteractionroot) */ -%>\n\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.cpswt.utils.CpswtUtils;\n\n<% if(isinteraction){ -%>\nimport hla.rti.FederateNotExecutionMember;\nimport hla.rti.InteractionClassNotDefined;\nimport hla.rti.InteractionClassNotPublished;\nimport hla.rti.InteractionClassNotSubscribed;\nimport hla.rti.LogicalTime;\nimport hla.rti.NameNotFound;\nimport hla.rti.RTIambassador;\nimport hla.rti.ReceivedInteraction;\n<% } else { -%>\nimport hla.rti.AttributeHandleSet;\nimport hla.rti.FederateNotExecutionMember;\nimport hla.rti.LogicalTime;\nimport hla.rti.NameNotFound;\nimport hla.rti.ObjectClassNotDefined;\nimport hla.rti.ObjectClassNotPublished;\nimport hla.rti.ObjectClassNotSubscribed;\nimport hla.rti.RTIambassador;\nimport hla.rti.ReflectedAttributes;\nimport hla.rti.SuppliedAttributes;\n<% } -%>\n<% if(simname !== 'org.cpswt.hla'){ -%>\n\nimport org.cpswt.hla.*;\n<% } -%>\n\n/**\n* Implements <%=hlaclassname%>\n*/\npublic class <%=classname%> extends <%=parentclassname%> {\n\n    private static final Logger logger = LogManager.getLogger();\n\n    /**\n    * Creates an instance of the <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class with default <%=isinteraction?\"parameter\":\"attribute\"%> values.\n    */\n    public <%=classname%>() {}\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\n\n<% /*alldatamembers:handle()*/ -%>\n<% alldatamembers.forEach(function(datamember){ -%>\n    private static int _<%=datamember.name%>_handle;\n<% }); -%>\n<% } -%>\n\n<% /*classcommon(...)*/ -%>\n<%- ejs.render(TEMPLATES[\"java/classcommon.java.ejs\"],\n    {   isinteraction: isinteraction,\n        classname: classname,\n        parentclassname: parentclassname,\n        hlaclassname: hlaclassname,\n        datamembers: datamembers,\n        alldatamembers: alldatamembers\n}) -%>\n<% if(isc2winteractionroot){ -%>\n\n    @Override\n    public void sendInteraction( RTIambassador rti, double time ) {\n        if (  get_sourceFed() == null || \"\".equals( get_sourceFed() ) || get_originFed() == null || \"\".equals( get_originFed() )  ) {\n            throw new Exception( \"source and/or origin federate not specified.\" );\n        }\n        super.sendInteraction( rti, time );\n    }\n\n    @Override\n    public void sendInteraction( RTIambassador rti ) {\n        if (  get_sourceFed() == null || \"\".equals( get_sourceFed() ) || get_originFed() == null || \"\".equals( get_originFed() )  ) {\n            throw new Exception( \"source and/or origin federate not specified.\" );\n        }\n        super.sendInteraction( rti );\n    }\n<% } -%>\n<% if(isinteraction){ -%>\n<% if(datamembers && datamembers.length > 0){ -%>\n\n<% datamembers.forEach(function(parameter){ -%>\n<% /*datamembers:interactionmembers()*/ -%>\n    private <%=parameter.parameterType%> _<%=parameter.name%> = <%-helpers.initialvalue(parameter.parameterType)%>;\n<% }); -%>\n\n<% datamembers.forEach(function(parameter){ -%>\n<% /*datamembers:interactionsetters()*/ -%>\n    /**\n    * Set the value of the \"<%=parameter.name%>\" parameter to \"value\" for this parameter.\n    *\n    * @param value the new value for the \"<%=parameter.name%>\" parameter\n    */\n    public void set_<%=parameter.name%>( <%=parameter.parameterType%> value ) {\n        _<%=parameter.name%> = value;\n    }\n\n<% /*datamembers:interactiongetters()*/ -%>\n    /**\n    * Returns the value of the \"<%=parameter.name%>\" parameter of this interaction.\n    *\n    * @return the value of the \"<%=parameter.name%>\" parameter\n    */\n    public <%=parameter.parameterType%> get_<%=parameter.name%>() {\n        return _<%=parameter.name%>;\n    }\n<% }); -%>\n<% } -%>\n<% }else{ %>\n<% alldatamembers.forEach(function(attribute){ -%>\n\n<% /* alldatamembers:{ a |<publish(attribute=a)> } */ -%>\n    /**\n    * Publishes the \"<%=attribute.name%>\" attribute of the attribute's containing object\n    * class for a federate.\n    * Note:  This method only marks the \"<%=attribute.name%>\" attribute for publication.\n    * To actually publish the attribute, the federate must (re)publish its containing\n    * object class.\n    * (using &lt;objectClassName&gt;.publish( RTIambassador rti ) ).\n    */\n    public static void publish_<%=attribute.name%>() {\n        _publishAttributeNameSet.add( \"<%=attribute.name%>\" );\n    }\n\n    /**\n    * Unpublishes the \"<%=attribute.name%>\" attribute of the attribute's containing object\n    * class for a federate.\n    * Note:  This method only marks the \"<%=attribute.name%>\" attribute for unpublication.\n    * To actually publish the attribute, the federate must (re)publish its containing\n    * object class.\n    * (using &lt;objectClassName&gt;.publish( RTIambassador rti ) ).\n    */\n    public static void unpublish_<%=attribute.name%>() {\n        _publishAttributeNameSet.remove( \"<%=attribute.name%>\" );\n    }\n\n<% /* alldatamembers:{ a |<subscribe(attribute=a)> } */ -%>\n    /**\n    * Subscribes a federate to the \"<%=attribute.name%>\" attribute of the attribute's\n    * containing object class.\n    * Note:  This method only marks the \"<%=attribute.name%>\" attribute for subscription.\n    * To actually subscribe to the attribute, the federate must (re)subscribe to its\n    * containing object class.\n    * (using &lt;objectClassName&gt;.subscribe( RTIambassador rti ) ).\n    */\n    public static void subscribe_<%=attribute.name%>() {\n        _subscribeAttributeNameSet.add( \"<%=attribute.name%>\" );\n    }\n\n    /**\n    * Unsubscribes a federate from the \"<%=attribute.name%>\" attribute of the attribute's\n    * containing object class.\n    * Note:  This method only marks the \"<%=attribute.name%>\" attribute for unsubscription.\n    * To actually unsubscribe to the attribute, the federate must (re)subscribe to its\n    * containing object class.\n    * (using &lt;objectClassName&gt;.subscribe( RTIambassador rti ) ).\n    */\n    public static void unsubscribe_<%=attribute.name%>() {\n        _subscribeAttributeNameSet.remove( \"<%=attribute.name%>\" );\n    }\n<% }); -%>\n<% datamembers.forEach(function(datamember){ -%>\n\n<% /*datamembers:objectmembers()*/ -%>\n    protected Attribute< <%= helpers.primitive2object(datamember.parameterType) %> > _<%=datamember.name%> =\n            new Attribute< <%= helpers.primitive2object(datamember.parameterType) %> >(  new <%= helpers.primitive2object(datamember.parameterType)%>( <%-helpers.initialvalue(datamember.parameterType)%> )  );\n\n<% /*datamembers:objectsetters()*/ -%>\n    /**\n    * Set the value of the \"<%=datamember.name%>\" attribute to \"value\" for this object.\n    *\n    * @param value the new value for the \"<%=datamember.name%>\" attribute\n    */\n    public void set_<%=datamember.name%>( <%=datamember.parameterType%> value ) {\n        _<%=datamember.name%>.setValue( value );\n        _<%=datamember.name%>.setTime( getTime() );\n    }\n\n<% /*datamembers:objectgetters()*/ -%>\n    /**\n    * Returns the value of the \"<%=datamember.name%>\" attribute of this object.\n    *\n    * @return the value of the \"<%=datamember.name%>\" attribute\n    */\n    public <%=datamember.parameterType%> get_<%=datamember.name%>() {\n        return _<%=datamember.name%>.getValue();\n    }\n\n<% /*datamembers:objecttimegetters()*/ -%>\n    /**\n    * Returns the current timestamp of the \"<%=datamember.name%>\" attribute of this object.\n    *\n    * @return the current timestamp of the \"<%=datamember.name%>\" attribute\n    */\n    public double get_<%=datamember.name%>_time() {\n        return _<%=datamember.name%>.getTime();\n    }\n<% }); -%>\n<% } -%>\n\n    protected <%=classname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, boolean initFlag ) {\n        super( datamemberMap, false );\n        if ( initFlag ) set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>s( datamemberMap );\n    }\n\n    protected <%=classname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime, boolean initFlag ) {\n        super( datamemberMap, logicalTime, false );\n        if ( initFlag ) set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>s( datamemberMap );\n    }\n\n    /**\n    * Creates an instance of the <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class, using\n    * \"datamemberMap\" to initialize its <%=isinteraction?\"parameter\":\"attribute\"%> values.\n    * \"datamemberMap\" is usually acquired as an argument to an RTI federate\n    * callback method, such as \"receiveInteraction\".\n    *\n    * @param datamemberMap data structure containing initial values for the\n    * <%=isinteraction?\"parameter\":\"attribute\"%>s of this new <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance\n    */\n    public <%=classname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap ) {\n        this( datamemberMap, true );\n    }\n\n    /**\n    * Like {@link #<%=classname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap )}, except this\n    * new <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance is given a timestamp of\n    * \"logicalTime\".\n    *\n    * @param datamemberMap data structure containing initial values for the\n    * <%=isinteraction?\"parameter\":\"attribute\"%>s of this new <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance\n    * @param logicalTime timestamp for this new <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class\n    * instance\n    */\n    public <%=classname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime ) {\n        this( datamemberMap, logicalTime, true );\n    }\n\n    /**\n    * Creates a new <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance that is a duplicate\n    * of the instance referred to by <%=classname%>_var.\n    *\n    * @param <%=classname%>_var <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance of which\n    * this newly created <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance will be a\n    * duplicate\n    */\n    public <%=classname%>( <%=classname%> <%=classname%>_var ) {\n        super( <%=classname%>_var );\n<% if(datamembers && datamembers.length > 0){ -%>\n\n<% /*datamembers:{ d |<rticlasscopyvalue(classname=classname,datamember=d)>}*/ -%>\n<% datamembers.forEach(function(datamember){ -%>\n        set_<%=datamember.name%>( <%=classname%>_var.get_<%=datamember.name%>() );\n<% }); -%>\n<% } -%>\n    }\n<% if(datamembers && datamembers.length > 0){ -%>\n\n    /**\n    * Returns the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose name is \"datamemberName\"\n    * for this <%=isinteraction?\"interaction\":\"object\"%>.\n    *\n    * @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value is to be\n    * returned\n    * @return value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose name is \"datamemberName\"\n    * for this <%=isinteraction?\"interaction\":\"object\"%>\n    */\n    public Object get<%= isinteraction ? \"Parameter\" : \"Attribute\" %>( String datamemberName ) {\n<% /*first(datamembers):startgetbyname()*/ -%>\n<% /*rest(datamembers):continuegetbyname()*/ -%>\n<% for(var i = 0; i<datamembers.length; i++ ){ -%>\n        <%= i == 0  ? 'if' : 'else if'%> ( \"<%=datamembers[i].name%>\".equals(datamemberName) ) return <%=helpers.get(datamembers[i].parameterType, datamembers[i].name)%>;\n<% } -%>\n        else return super.get<%= isinteraction ? \"Parameter\" : \"Attribute\" %>( datamemberName );\n    }\n\n    protected boolean set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>Aux( String datamemberName, String val ) {\n        boolean retval = true;\n<% /*first(datamembers):startifstring()*/ -%>\n<% /*rest(datamembers):continueifstring()*/ -%>\n<% for(var i = 0; i<datamembers.length; i++ ){ -%>\n        <%= i == 0  ? 'if' : 'else if'%> ( \"<%=datamembers[i].name%>\".equals( datamemberName) ) set_<%=datamembers[i].name%>( <%=helpers.set(datamembers[i].parameterType)%> );\n<% } -%>\n        else retval = super.set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>Aux( datamemberName, val );\n\n        return retval;\n    }\n\n    protected boolean set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>Aux( String datamemberName, Object val ) {\n        boolean retval = true;\n<% /*first(datamembers):startifname()*/ -%>\n<% /*rest(datamembers):continueifname()*/ -%>\n<% for(var i = 0; i<datamembers.length; i++ ){ -%>\n        <%= i == 0  ? 'if' : 'else if'%> ( \"<%=datamembers[i].name%>\".equals( datamemberName) ) set_<%=datamembers[i].name%>( (<%= helpers.primitive2object(datamembers[i].parameterType)%>)val );\n<% } -%>\n        else retval = super.set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>Aux( datamemberName, val );\n\n        return retval;\n    }\n<% } -%>\n<% if(!isinteraction){ -%>\n\n    @Override\n    protected SuppliedAttributes createSuppliedDatamembers(boolean force) {\n        SuppliedAttributes datamembers = _factory.createSuppliedAttributes();\n <% alldatamembers.forEach(function(datamember){ -%>\n\n        if (_publishAttributeNameSet.contains(\"<%=datamember.name%>\") && _<%=datamember.name%>.shouldBeUpdated(force)) {\n            datamembers.add( getAttributeHandle(\"<%=datamember.name%>\"), getAttribute(\"<%=datamember.name%>\").toString().getBytes() );\n            _<%=datamember.name%>.setHasBeenUpdated();\n        }\n<% }); -%>\n\n        return datamembers;\n    }\n<% } -%>\n\n    public void copyFrom( Object object ) {\n        super.copyFrom( object );\n        if ( object instanceof <%=classname%> ) {\n            <%=classname%> data = (<%=classname%>)object;\n<% /*datamembers:copydatamember();separator = \"\\n\"*/ -%>\n<% datamembers.forEach(function(datamember){ -%>\n            _<%=datamember.name%> = data._<%=datamember.name%>;\n<% }); -%>\n        }\n    }\n}\n\n",
    "java/classcommon.java.ejs": "<% /*classcommon(isinteraction,classname,parentclassname,hlaclassname,datamembers,alldatamembers) */ -%>\n    private static boolean _isInitialized = false;\n\n    private static int _handle;\n\n    /**\n    * Returns the handle (RTI assigned) of the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class.\n    * Note: As this is a static method, it is NOT polymorphic, and so, if called on\n    * a reference will return the handle of the class pertaining to the reference,\n    * rather than the handle of the class for the instance referred to by the reference.\n    * For the polymorphic version of this method, use {@link #getClassHandle()}.\n    *\n    * @return the RTI assigned integer handle that represents this <%=isinteraction?\"interaction\":\"object\"%> class\n    */\n    public static int get_handle() {\n        return _handle;\n    }\n\n    /**\n    * Returns the fully-qualified (dot-delimited) name of the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class.\n    * Note: As this is a static method, it is NOT polymorphic, and so, if called on\n    * a reference will return the name of the class pertaining to the reference,\n    * rather than the name of the class for the instance referred to by the reference.\n    * For the polymorphic version of this method, use {@link #getClassName()}.\n    *\n    * @return the fully-qualified HLA class path for this <%=isinteraction?\"interaction\":\"object\"%> class\n    */\n    public static String get_class_name() {\n        return \"<%=hlaclassname%>\";\n    }\n\n    /**\n    * Returns the simple name (the last name in the dot-delimited fully-qualified\n    * class name) of the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class.\n    *\n    * @return the name of this <%=isinteraction?\"interaction\":\"object\"%> class\n    */\n    public static String get_simple_class_name() {\n        return \"<%= classname %>\";\n    }\n\n    private static Set< String > _datamemberNames = new HashSet< String >();\n    private static Set< String > _allDatamemberNames = new HashSet< String >();\n\n    /**\n    * Returns a set containing the names of all of the non-hidden <%=isinteraction?\"parameter\":\"attribute\"%>s in the\n    * <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class.\n    * Note: As this is a static method, it is NOT polymorphic, and so, if called on\n    * a reference will return a set of parameter names pertaining to the reference,\n    * rather than the parameter names of the class for the instance referred to by\n    * the reference.  For the polymorphic version of this method, use\n    * {@link #get<%=isinteraction?\"Parameter\":\"Attribute\"%>Names()}.\n    *\n    * @return a modifiable set of the non-hidden <%=isinteraction?\"parameter\":\"attribute\"%> names for this <%=isinteraction?\"interaction\":\"object\"%> class\n    */\n    public static Set< String > get_<%=isinteraction?\"parameter\":\"attribute\"%>_names() {\n        return new HashSet< String >(_datamemberNames);\n    }\n\n    /**\n    * Returns a set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s in the\n    * <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class.\n    * Note: As this is a static method, it is NOT polymorphic, and so, if called on\n    * a reference will return a set of parameter names pertaining to the reference,\n    * rather than the parameter names of the class for the instance referred to by\n    * the reference.  For the polymorphic version of this method, use\n    * {@link #get<%=isinteraction?\"Parameter\":\"Attribute\"%>Names()}.\n    *\n    * @return a modifiable set of the <%=isinteraction?\"parameter\":\"attribute\"%> names for this <%=isinteraction?\"interaction\":\"object\"%> class\n    */\n    public static Set< String > get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names() {\n        return new HashSet< String >(_allDatamemberNames);\n    }\n<% if(!isinteraction){ -%>\n\n    private static Set< String > _publishAttributeNameSet = new HashSet< String >();\n    private static Set< String > _subscribeAttributeNameSet = new HashSet< String >();\n<% } -%>\n\n    static {\n        _classNameSet.add(\"<%= hlaclassname %>\");\n        _classNameClassMap.put(\"<%= hlaclassname %>\", <%= classname %>.class);\n\n        _datamemberClassNameSetMap.put(\"<%= hlaclassname %>\", _datamemberNames);\n        _allDatamemberClassNameSetMap.put(\"<%= hlaclassname %>\", _allDatamemberNames);\n<% if(datamembers && datamembers.length > 0){ -%>\n\n<% /*datamembers:initDatamemberNameSet()*/ -%>\n<% datamembers.forEach(function(datamember){ -%>\n<% if(!datamember.hidden && !datamember.inherited){ -%>\n        _datamemberNames.add(\"<%=datamember.name%>\");\n<% } -%>\n<% }); -%>\n\n<% /*datamembers:initDatamemberTypeMap()*/ -%>\n<% datamembers.forEach(function(datamember){ -%>\n        _datamemberTypeMap.put(\"<%=datamember.name%>\", \"<%=datamember.parameterType%>\");\n<% }); -%>\n<% } -%>\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\n\n<% /*alldatamembers:initAllDatamemberNameSet()*/ -%>\n<% alldatamembers.forEach(function(datamember){ -%>\n        _allDatamemberNames.add(\"<%=datamember.name%>\");\n<% }); -%>\n<% } -%>\n<% if(!isinteraction){ -%>\n\n        _classNamePublishAttributeNameMap.put(\"<%= hlaclassname %>\", _publishAttributeNameSet);\n        _classNameSubscribeAttributeNameMap.put(\"<%= hlaclassname %>\", _subscribeAttributeNameSet);\n<% } -%>\n    }\n\n    protected static void init(RTIambassador rti) {\n        if (_isInitialized) return;\n        _isInitialized = true;\n\n        <% if(parentclassname){ %><%=parentclassname%>.init(rti);<%}%>\n\n        boolean isNotInitialized = true;\n        while(isNotInitialized) {\n            try {\n                _handle = rti.get<%=isinteraction?\"Interaction\":\"Object\"%>ClassHandle(\"<%= hlaclassname %>\");\n                isNotInitialized = false;\n            } catch (FederateNotExecutionMember e) {\n                logger.error(\"could not initialize: Federate Not Execution Member\", e);\n                return;\n            } catch (NameNotFound e) {\n                logger.error(\"could not initialize: Name Not Found\", e);\n                return;\n            } catch (Exception e) {\n                logger.error(e);\n                CpswtUtils.sleepDefault();\n            }\n        }\n\n        _classNameHandleMap.put(\"<%= hlaclassname %>\", get_handle());\n        _classHandleNameMap.put(get_handle(), \"<%= hlaclassname %>\");\n        _classHandleSimpleNameMap.put(get_handle(), \"<%= classname %>\");\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\n\n        isNotInitialized = true;\n        while(isNotInitialized) {\n            try {\n<% /*alldatamembers:handle_init()*/ -%>\n<% alldatamembers.forEach(function(datamember){ -%>\n                _<%=datamember.name%>_handle = rti.get<%=isinteraction?\"Parameter\":\"Attribute\"%>Handle(\"<%=datamember.name%>\", get_handle());\n<% }); -%>\n                isNotInitialized = false;\n            } catch (FederateNotExecutionMember e) {\n                logger.error(\"could not initialize: Federate Not Execution Member\", e);\n                return;\n            } catch (<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined e) {\n                logger.error(\"could not initialize: <%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\", e);\n                return;\n            } catch (NameNotFound e) {\n                logger.error(\"could not initialize: Name Not Found\", e);\n                return;\n            } catch (Exception e) {\n                logger.error(e);\n                CpswtUtils.sleepDefault();\n            }\n        }\n\n<% /*alldatamembers: { d |<initDatamemberNameHandleMap(hlaclassname=hlaclassname,datamember=d)>}*/ -%>\n<% alldatamembers.forEach(function(datamember){ -%>\n        _datamemberNameHandleMap.put(\"<%=hlaclassname%>.<%=datamember.name%>\", _<%=datamember.name%>_handle);\n<% }); -%>\n\n<% /*alldatamembers:initDatamemberHandleNameMap()*/ -%>\n<% alldatamembers.forEach(function(datamember){ -%>\n        _datamemberHandleNameMap.put(_<%=datamember.name%>_handle, \"<%=datamember.name%>\");\n<% }); -%>\n<% } -%>\n    }\n\n    private static boolean _isPublished = false;\n\n    /**\n    * Publishes the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class for a federate.\n    *\n    * @param rti handle to the Local RTI Component\n    */\n    public static void publish(RTIambassador rti) {\n        if (_isPublished) return;\n\n        init(rti);\n<% if(!isinteraction){ -%>\n\n        AttributeHandleSet publishedAttributeHandleSet = _factory.createAttributeHandleSet();\n        for(String attributeName : _publishAttributeNameSet) {\n            try {\n                publishedAttributeHandleSet.add(_datamemberNameHandleMap.get(\"<%= hlaclassname %>.\" + attributeName));\n                logger.trace(\"publish {}:{}\", get_class_name(), attributeName);\n            } catch (Exception e) {\n                logger.error(\"could not publish \\\"\" + attributeName + \"\\\" attribute.\", e);\n            }\n        }\n<% } -%>\n\n        synchronized(rti) {\n            boolean isNotPublished = true;\n            while(isNotPublished) {\n                try {\n                    rti.publish<%=isinteraction?\"Interaction\":\"Object\"%>Class(get_handle()<% if(!isinteraction){ %>, publishedAttributeHandleSet<%}%>);\n                    isNotPublished = false;\n                } catch (FederateNotExecutionMember e) {\n                    logger.error(\"could not publish: Federate Not Execution Member\", e);\n                    return;\n                } catch (<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined e) {\n                    logger.error(\"could not publish: <%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\", e);\n                    return;\n                } catch (Exception e) {\n                    logger.error(e);\n                    CpswtUtils.sleepDefault();\n                }\n            }\n        }\n\n        _isPublished = true;\n        logger.debug(\"publish: {}\", get_class_name());\n    }\n\n    /**\n    * Unpublishes the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class for a federate.\n    *\n    * @param rti handle to the Local RTI Component\n    */\n    public static void unpublish(RTIambassador rti) {\n        if (!_isPublished) return;\n\n        init(rti);\n\n        synchronized(rti) {\n            boolean isNotUnpublished = true;\n            while(isNotUnpublished) {\n                try {\n                    rti.unpublish<%=isinteraction?\"Interaction\":\"Object\"%>Class(get_handle());\n                    isNotUnpublished = false;\n                } catch (FederateNotExecutionMember e) {\n                    logger.error(\"could not unpublish: Federate Not Execution Member\", e);\n                    return;\n                } catch (<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined e) {\n                    logger.error(\"could not unpublish: <%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\", e);\n                    return;\n                } catch (<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotPublished e) {\n                    logger.error(\"could not unpublish: <%=isinteraction?\"Interaction\":\"Object\"%> Class Not Published\", e);\n                    return;\n                } catch (Exception e) {\n                    logger.error(e);\n                    CpswtUtils.sleepDefault();\n                }\n            }\n        }\n\n        _isPublished = false;\n        logger.debug(\"unpublish: {}\", get_class_name());\n    }\n\n    private static boolean _isSubscribed = false;\n\n    /**\n    * Subscribes a federate to the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class.\n    *\n    * @param rti handle to the Local RTI Component\n    */\n    public static void subscribe(RTIambassador rti) {\n        if (_isSubscribed) return;\n\n        init(rti);\n<% if(!isinteraction){ -%>\n\n        AttributeHandleSet subscribedAttributeHandleSet = _factory.createAttributeHandleSet();\n        for(String attributeName : _subscribeAttributeNameSet) {\n            try {\n                subscribedAttributeHandleSet.add(_datamemberNameHandleMap.get(\"<%= hlaclassname %>.\" + attributeName));\n                logger.trace(\"subscribe {}:{}\", get_class_name(), attributeName);\n            } catch (Exception e) {\n                logger.error(\"could not subscribe to \\\"\" + attributeName + \"\\\" attribute.\", e);\n            }\n        }\n<% } -%>\n\n        synchronized(rti) {\n            boolean isNotSubscribed = true;\n            while(isNotSubscribed) {\n                try {\n                    rti.subscribe<% if(isinteraction){ %>InteractionClass(get_handle())<% }else{ %>ObjectClassAttributes(get_handle(), subscribedAttributeHandleSet)<%}%>;\n                    isNotSubscribed = false;\n                } catch (FederateNotExecutionMember e) {\n                    logger.error(\"could not subscribe: Federate Not Execution Member\", e);\n                    return;\n                } catch (<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined e) {\n                    logger.error(\"could not subscribe: <%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\", e);\n                    return;\n                } catch (Exception e) {\n                    logger.error(e);\n                    CpswtUtils.sleepDefault();\n                }\n            }\n        }\n\n        _isSubscribed = true;\n        logger.debug(\"subscribe: {}\", get_class_name());\n    }\n\n    /**\n    * Unsubscribes a federate from the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class.\n    *\n    * @param rti handle to the Local RTI Component\n    */\n    public static void unsubscribe(RTIambassador rti) {\n        if (!_isSubscribed) return;\n\n        init(rti);\n\n        synchronized(rti) {\n            boolean isNotUnsubscribed = true;\n            while(isNotUnsubscribed) {\n                try {\n                    rti.unsubscribe<%=isinteraction?\"Interaction\":\"Object\"%>Class(get_handle());\n                    isNotUnsubscribed = false;\n                } catch (FederateNotExecutionMember e) {\n                    logger.error(\"could not unsubscribe: Federate Not Execution Member\", e);\n                    return;\n                } catch (<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined e) {\n                    logger.error(\"could not unsubscribe: <%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\", e);\n                    return;\n                } catch (<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotSubscribed e) {\n                    logger.error(\"could not unsubscribe: <%=isinteraction?\"Interaction\":\"Object\"%> Class Not Subscribed\", e);\n                    return;\n                } catch (Exception e) {\n                    logger.error(e);\n                    CpswtUtils.sleepDefault();\n                }\n            }\n        }\n\n        _isSubscribed = false;\n        logger.debug(\"unsubscribe: {}\", get_class_name());\n    }\n\n    /**\n    * Return true if \"handle\" is equal to the handle (RTI assigned) of this class\n    * (that is, the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class).\n    *\n    * @param handle handle to compare to the value of the handle (RTI assigned) of\n    * this class (the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class).\n    * @return \"true\" if \"handle\" matches the value of the handle of this class\n    * (that is, the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class).\n    */\n    public static boolean match(int handle) {\n        return handle == get_handle();\n    }\n\n    /**\n    * Returns the handle (RTI assigned) of this instance's <%=isinteraction?\"interaction\":\"object\"%> class .\n    *\n    * @return the handle (RTI assigned) if this instance's <%=isinteraction?\"interaction\":\"object\"%> class\n    */\n    public int getClassHandle() {\n        return get_handle();\n    }\n\n    /**\n    * Returns the fully-qualified (dot-delimited) name of this instance's <%=isinteraction?\"interaction\":\"object\"%> class.\n    *\n    * @return the fully-qualified (dot-delimited) name of this instance's <%=isinteraction?\"interaction\":\"object\"%> class\n    */\n    public String getClassName() {\n        return get_class_name();\n    }\n\n    /**\n    * Returns the simple name (last name in its fully-qualified dot-delimited name)\n    * of this instance's <%=isinteraction?\"interaction\":\"object\"%> class.\n    *\n    * @return the simple name of this instance's <%=isinteraction?\"interaction\":\"object\"%> class\n    */\n    public String getSimpleClassName() {\n        return get_simple_class_name();\n    }\n\n    /**\n    * Returns a set containing the names of all of the non-hidden<%=isinteraction?\"parameter\":\"attribute\"%>s of an\n    * <%=isinteraction?\"interaction\":\"object\"%> class instance.\n    *\n    * @return set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s of an\n    * <%=isinteraction?\"interaction\":\"object\"%> class instance\n    */\n    public Set< String > get<%=isinteraction?\"Parameter\":\"Attribute\"%>Names() {\n        return get_<%=isinteraction?\"parameter\":\"attribute\"%>_names();\n    }\n\n    /**\n    * Returns a set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s of an\n    * <%=isinteraction?\"interaction\":\"object\"%> class instance.\n    *\n    * @return set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s of an\n    * <%=isinteraction?\"interaction\":\"object\"%> class instance\n    */\n    public Set< String > getAll<%=isinteraction?\"Parameter\":\"Attribute\"%>Names() {\n        return get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names();\n    }\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\n\n    @Override\n    public String get<%=isinteraction?\"Parameter\":\"Attribute\"%>Name(int datamemberHandle) {\n<% for(var i = 0; i<alldatamembers.length; i++ ){ -%>\n        <%= i == 0 ? 'if' : 'else if'%> (datamemberHandle == _<%=alldatamembers[i].name%>_handle) return \"<%=alldatamembers[i].name%>\";\n<% } -%>\n        else return super.get<%=isinteraction?\"Parameter\":\"Attribute\"%>Name(datamemberHandle);\n    }\n<% } -%>\n\n    /**\n    * Publishes the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of the class for a federate.\n    *\n    * @param rti handle to the Local RTI Component\n    */\n    public void publish<%=isinteraction?\"Interaction\":\"Object\"%>(RTIambassador rti) {\n        publish(rti);\n    }\n\n    /**\n    * Unpublishes the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of this class for a federate.\n    *\n    * @param rti handle to the Local RTI Component\n    */\n    public void unpublish<%=isinteraction?\"Interaction\":\"Object\"%>(RTIambassador rti) {\n        unpublish(rti);\n    }\n\n    /**\n    * Subscribes a federate to the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of this class.\n    *\n    * @param rti handle to the Local RTI Component\n    */\n    public void subscribe<%=isinteraction?\"Interaction\":\"Object\"%>(RTIambassador rti) {\n        subscribe(rti);\n    }\n\n    /**\n    * Unsubscribes a federate from the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of this class.\n    *\n    * @param rti handle to the Local RTI Component\n    */\n    public void unsubscribe<%=isinteraction?\"Interaction\":\"Object\"%>(RTIambassador rti) {\n        unsubscribe(rti);\n    }\n\n    @Override\n    public String toString() {\n        return getClass().getName() + \"(\"\n<% /*alldatamembers:stringValue(); separator=\"+ \\\",\\\"\"*/ -%>\n<% var separator = false; alldatamembers.forEach(function(datamember){ -%>\n                <%if(separator){%>+ \",\" <%}else{separator=true;}%>+ \"<%=datamember.name%>:\" + get_<%=datamember.name%>()\n<% }); -%>\n                + \")\";\n    }\n",
    "java/classroot.java.ejs": "\n\n// This code has been generated by the C2W code generator.\n// Do not edit manually!\n\n<%/* THIS IS THE ROOT CLASS OF EITHER THE INTERACTION OR OBJECT-CLASS HEIRARCHY (I.E. \"InteractionRoot\" OR \"ObjectRoot\") */%>\n<%/*classroot(isinteraction)*/%>\n\n/*\n * Copyright (c) 2016, Institute for Software Integrated Systems, Vanderbilt University\n * All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this software and its\n * documentation for any purpose, without fee, and without written agreement is\n * hereby granted, provided that the above copyright notice, the following\n * two paragraphs and the author appear in all copies of this software.\n *\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n * @author Himanshu Neema\n */\n\npackage org.cpswt.hla;\n\nimport hla.rti.*;\nimport hla.rti.jlc.RtiFactory;\nimport hla.rti.jlc.RtiFactoryFactory;\n\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n<% if(isinteraction){%>import java.util.concurrent.LinkedBlockingQueue;<%}%>\n\nimport org.portico.impl.hla13.types.DoubleTime;\n\n/**\n * <%=isinteraction?\"Interaction\":\"Object\"%>Root is the base class for all <%=isinteraction?\"interaction\":\"object\"%>s\n * defined in a given federation.  As such, an <%=isinteraction?\"Interaction\":\"Object\"%>Root\n * variable may refer to any type of interaction defined in the\n * federation.\n * <p/>\n * This <%=isinteraction?\"Interaction\":\"Object\"%>Root class provides the following:\n * - methods for constructing any <%=isinteraction?\"interaction\":\"object\"%> in the federation, either from\n * data provided by the RTI (for example, see\n * {@link #create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle )} or from a string argument\n * specifying the name of <%=isinteraction?\"interaction\":\"object\"%> to construct (see\n * {@link #create_<%=isinteraction?\"interaction\":\"object\"%>( String className )}.\n * - methods for sending <% if(isinteraction){ %>an interaction<%}else{%>object updates<%}%> to the RTI (see\n * {@link <% if(isinteraction){ %>#sendInteraction( RTIambassador rti )<%}else{%>#updateAttributeValues( RTIambassador rti )<%}%>} for an example).\n * - methods for publishing/subscribing to any <% if(isinteraction){ %>interaction<%}else{%>object/object attribute<%}%> \n * defined in the federation (see\n * {@link #publish( String className, RTIambassador rti )} for example).\n * - methods for getting/setting any <%=isinteraction?\"parameter\":\"attribute\"%> in the <%=isinteraction?\"interaction\":\"object\"%> to\n * which a given <%=isinteraction?\"Interaction\":\"Object\"%>Root variable is referring\n * (see {@link #get<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName )} and\n * {@link #set<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName, Object value )}\n */\npublic class <%=isinteraction?\"Interaction\":\"Object\"%>Root implements <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface {\n\n\tprivate static int logId = 0;\n\tprivate static int _globalUniqueID = 0;\n\t\n\tprivate static int generateUniqueID() {\n\t\treturn _globalUniqueID++;\n\t}\n\t\n\tprivate int _uniqueID;\n\t\n\tpublic int getUniqueID() { return _uniqueID; }\n\t\n\tprotected static RtiFactory _factory;\n\tstatic {\n\t\tboolean factoryNotAcquired = true;\n\t\twhile( factoryNotAcquired ) {\n\t\t\ttry {\n\t\t\t\t_factory = RtiFactoryFactory.getRtiFactory( \"org.portico.dlc.HLA13RTIFactory\" );\n\t\t\t\tfactoryNotAcquired = false;\n\t\t\t} catch ( Exception e ) {\n\t\t\t\tSystem.err.println( \"ERROR: acquiring factory\" );\n\t\t\t\te.printStackTrace();\n\t\t\t\ttry { Thread.sleep( 100 ); } catch ( Exception e1 ) { }\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected static Set< String > _classNameSet = new HashSet< String >();\n\tprotected static Map< String, Class<?> > _classNameClassMap = new HashMap< String, Class<?> >();\n\tprotected static Map<  String, Set< String >  > _datamemberClassNameSetMap = new HashMap<  String, Set< String >  >();\n\tprotected static Map<  String, Set< String >  > _allDatamemberClassNameSetMap = new HashMap<  String, Set< String >  >();\n\n\tprotected static Map< String, Integer > _classNameHandleMap = new HashMap< String, Integer >();\n\tprotected static Map< Integer, String > _classHandleNameMap = new HashMap< Integer, String >();\n\tprotected static Map< Integer, String > _classHandleSimpleNameMap = new HashMap< Integer, String >();\n\t\n\tprotected static Map< String, Integer > _datamemberNameHandleMap = new HashMap< String, Integer >();\n\tprotected static Map< Integer, String > _datamemberHandleNameMap = new HashMap< Integer, String >();\n\tprotected static Map< String, String > _datamemberTypeMap = new HashMap< String, String >();\n\n<% if(isinteraction){ %><%}else{%>\n\tprotected static Map<  String, Set< String >  > _classNamePublishAttributeNameMap = new HashMap<  String, Set< String >  >();\n\tprotected static Map<  String, Set< String >  > _classNameSubscribeAttributeNameMap = new HashMap<  String, Set< String >  >();\n\n\tprotected static Map< String, AttributeHandleSet > _classNamePublishedAttributeMap = new HashMap< String, AttributeHandleSet >();\n\tprotected static Map< String, AttributeHandleSet > _classNameSubscribedAttributeMap = new HashMap< String, AttributeHandleSet >();\n\t\n    private static Map< Integer, ObjectRoot > _objectMap = new HashMap< Integer, ObjectRoot >();\n\n\tprotected static class Attribute<T> {                                                                                 // NOMELD\n\t\tprivate T _value = null;                                                                                           // NOMELD\n\t\tprivate T _oldValue = null;                                                                                        // NOMELD\n\t\tprivate boolean _oldValueInit = false;                                                                             // NOMELD\n\t\tprivate double _time = 0;                                                                                          // NOMELD\n                                                                                                                           // NOMELD\n\t\tpublic Attribute( T init ) {                                                                                       // NOMELD\n\t\t\t_value = init;                                                                                                 // NOMELD\n\t\t}                                                                                                                  // NOMELD\n\t\t                                                                                                                   // NOMELD\n\t\tpublic T getValue() { return _value; }                                                                             // NOMELD\n\t\tpublic void setValue( T value ) {                                                                                  // NOMELD\n\t\t\tif ( value == null ) return;                                                                                   // NOMELD\n\t\t\t_value = value;                                                                                                // NOMELD\n\t\t}                                                                                                                  // NOMELD\n\t\t                                                                                                                   // NOMELD\n\t\tpublic double getTime() { return _time; }                                                                          // NOMELD\n\t\tpublic void setTime( double time ) { _time = time; }                                                               // NOMELD\n\t\t                                                                                                                   // NOMELD\n\t\tpublic void setHasBeenUpdated() {                                                                                  // NOMELD\n\t\t\t_oldValue = _value;                                                                                            // NOMELD\n\t\t\t_oldValueInit = true;                                                                                          // NOMELD\n\t\t}                                                                                                                  // NOMELD\n\t\t                                                                                                                   // NOMELD\n\t\tpublic boolean shouldBeUpdated( boolean force ) { return force || !_oldValueInit || !_oldValue.equals( _value ); } // NOMELD\t\t\n\t}                                                                                                                      // NOMELD\n<%}%>\t\n\t\n\t<% /*classcommon(classname=%=isinteraction?\"Interaction\":\"Object\"%+\"Root\",hlaclassname=%=isinteraction?\"Interaction\":\"Object\"%+\"Root\",...)*/ %>\n\t<%- ejs.render(TEMPLATES[\"java/classcommon.java.ejs\"],\n\t\t{\n\t\t\tisinteraction: isinteraction,\n\t\t\tclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\n\t\t\tparentclassname: \"\",\n\t\t\thlaclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\n\t\t\tdatamembers: [],\n\t\t\talldatamembers: []\n\t}) %>\n\t/**\n\t* Returns a set of strings containing the names of all of the <%=isinteraction?\"interaction\":\"object\"%>\n\t* classes in the current federation.\n\t*\n\t* @return Set< String > containing the names of all <%=isinteraction?\"interaction\":\"object\"%> classes\n\t* in the current federation\n\t*/\n\tpublic static Set< String > get_<%=isinteraction?\"interaction\":\"object\"%>_names() { return new HashSet< String >( _classNameSet ); }\n\n\t/**\n\t* Returns a set of strings containing the names of all of the non-hidden <%=isinteraction?\"parameter\":\"attribute\"%>s\n\t* in the <%=isinteraction?\"interaction\":\"object\"%> class specified by className.\n\t*\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class for which to retrieve the\n\t* names of all of its <%=isinteraction?\"parameter\":\"attribute\"%>s\n\t* @return Set< String > containing the names of all <%=isinteraction?\"parameter\":\"attribute\"%>s in the\n\t* className <%=isinteraction?\"interaction\":\"object\"%> class\n\t*/\n\tpublic static Set< String > get_<%=isinteraction?\"parameter\":\"attribute\"%>_names( String className ) {\n\t\treturn new HashSet< String >(  _datamemberClassNameSetMap.get( className )  );\n\t}\n\t\n\t/**\n\t* Returns a set of strings containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s\n\t* in the <%=isinteraction?\"interaction\":\"object\"%> class specified by className.\n\t*\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class for which to retrieve the\n\t* names of all of its <%=isinteraction?\"parameter\":\"attribute\"%>s\n\t* @return Set< String > containing the names of all <%=isinteraction?\"parameter\":\"attribute\"%>s in the\n\t* className <%=isinteraction?\"interaction\":\"object\"%> class\n\t*/\n\tpublic static Set< String > get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names( String className ) {\n\t\treturn new HashSet< String >(  _allDatamemberClassNameSetMap.get( className )  );\n\t}\n\t\n\t/**\n\t* Returns the fully-qualified name of the <%=isinteraction?\"interaction\":\"object\"%> class corresponding\n\t* to the RTI-defined classHandle.\n\t*\n\t* @param classHandle handle (defined by RTI) of <%=isinteraction?\"interaction\":\"object\"%> class for\n\t* which to retrieve the fully-qualified name\n\t* @return the fully-qualified name of the <%=isinteraction?\"interaction\":\"object\"%> class that\n\t* corresponds to the RTI-defined classHandle\n\t*/\n\tpublic static String get_class_name( int classHandle ) {\n\t\treturn _classHandleNameMap.get( classHandle );\n\t}\n\n\t/**\n\t* Returns the simple name of the <%=isinteraction?\"interaction\":\"object\"%> class corresponding to the\n\t* RTI-defined classHandle.  The simple name of an <%=isinteraction?\"interaction\":\"object\"%> class is\n\t* the last name in its (dot-delimited) fully-qualified name.\n\t*\n\t* @param classHandle handle (defined by RTI) of <%=isinteraction?\"interaction\":\"object\"%> class for which\n\t* to retrieve the simple name\n\t* @return the simple name of the <%=isinteraction?\"interaction\":\"object\"%> class that corresponds to\n\t* the RTI-defined classHandle\n\t*/\n\tpublic static String get_simple_class_name( int classHandle ) {\n\t\treturn _classHandleSimpleNameMap.get( classHandle );\n\t}\n\t\n\t/**\n\t* Returns the integer handle (RTI defined) of the <%=isinteraction?\"interaction\":\"object\"%> class\n\t* corresponding to the fully-qualified <%=isinteraction?\"interaction\":\"object\"%> class name in className.\n\t*\n\t* @param className fully-qualified name of <%=isinteraction?\"interaction\":\"object\"%> class for which to\n\t* retrieve the RTI-defined integer handle\n\t* @return the RTI-defined handle of the <%=isinteraction?\"interaction\":\"object\"%> class\n\t*/\n\tpublic static int get_handle( String className ) {\n\t\n\t\tInteger classHandle = _classNameHandleMap.get( className );\n\t\tif ( classHandle == null ) {\n\t\t\tSystem.err.println( \"Bad class name \\\"\" + className + \"\\\" on get_handle.\" );\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\treturn classHandle;\t\t\n\t}\n\t\n\t/**\n\t* Returns the name of <% if(isinteraction){ %>a parameter<%}else{%>an attribute<%}%> corresponding to\n\t* its handle (RTI assigned) in datamemberHandle.\n\t*\n\t* @param datamemberHandle handle of <% if(isinteraction){ %>parameter<%}else{%>attribute<%}%> (RTI assigned)\n\t* for which to return the name\n\t* @return the name of the <% if(isinteraction){ %>parameter<%}else{%>attribute<%}%> corresponding to datamemberHandle\n\t*/\n\tpublic static String get_<%=isinteraction?\"parameter\":\"attribute\"%>_name( int datamemberHandle ) {\n\t\treturn _datamemberHandleNameMap.get( datamemberHandle );\n\t}\n\t\n\t/**\n\t* Returns the handle of <% if(isinteraction){ %>a parameter<%}else{%>an attribute<%}%> (RTI assigned) given\n\t* its <%=isinteraction?\"interaction\":\"object\"%> class name and <%=isinteraction?\"parameter\":\"attribute\"%> name\n\t*\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class\n\t* @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%>\n\t* @return the handle (RTI assigned) of the <%=isinteraction?\"parameter\":\"attribute\"%> \"datamemberName\" of <%=isinteraction?\"interaction\":\"object\"%> class \"className\"\n\t*/\n\tpublic static int get_<%=isinteraction?\"parameter\":\"attribute\"%>_handle( String className, String datamemberName ) {\n\t\n\t\tInteger datamemberHandle = _datamemberNameHandleMap.get( className + \",\" + datamemberName );\n\t\tif ( datamemberHandle == null ) {\n\t\t\tSystem.err.println( \"Bad <%=isinteraction?\"parameter\":\"attribute\"%> \\\"\" + datamemberName + \"\\\" for class \\\"\" + className + \"\\\" on get_<%=isinteraction?\"parameter\":\"attribute\"%>_handle.\" );\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\treturn datamemberHandle;\t\t\n\t}\n\t\n\tprivate static Class<?>[] pubsubArguments = new Class<?>[] { RTIambassador.class };\n\t\n\t\n\t/**\n\t* Publishes the <%=isinteraction?\"interaction\":\"object\"%> class named by \"className\" for a federate.\n\t* This can also be performed by calling the publish( RTIambassador rti )\n\t* method directly on the <%=isinteraction?\"interaction\":\"object\"%> class named by \"className\" (for\n\t* example, to publish the <%=isinteraction?\"Interaction\":\"Object\"%>Root class in particular,\n\t* see {@link <%=isinteraction?\"Interaction\":\"Object\"%>Root#publish( RTIambassador rti )}).\n\t*\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class to be published for the federate\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t*/\n\tpublic static void publish( String className, RTIambassador rti ) {\n\t\tClass<?> rtiClass = _classNameClassMap.get( className );\n\t\tif ( rtiClass == null ) {\n\t\t\tSystem.err.println( \"Bad class name \\\"\" + className + \"\\\" on publish.\" );\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tMethod method = rtiClass.getMethod( \"publish\", pubsubArguments );\n\t\t\tmethod.invoke( null, new Object[]{ rti } );\n\t\t} catch ( Exception e ) {\n\t\t\tSystem.err.println( \"Exception caught on publish!\" );\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\t/**\n\t* Unpublishes the <%=isinteraction?\"interaction\":\"object\"%> class named by \"className\" for a federate.\n\t* This can also be performed by calling the unpublish( RTIambassador rti )\n\t* method directly on the <%=isinteraction?\"interaction\":\"object\"%> class named by \"className\" (for\n\t* example, to unpublish the <%=isinteraction?\"Interaction\":\"Object\"%>Root class in particular,\n\t* see {@link <%=isinteraction?\"Interaction\":\"Object\"%>Root#unpublish( RTIambassador rti )}).\n\t*\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class to be unpublished for the federate\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t*/\n\tpublic static void unpublish( String className, RTIambassador rti ) {\n\t\tClass<?> rtiClass = _classNameClassMap.get( className );\n\t\tif ( rtiClass == null ) {\n\t\t\tSystem.err.println( \"Bad class name \\\"\" + className + \"\\\" on unpublish.\" );\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tMethod method = rtiClass.getMethod( \"unpublish\", pubsubArguments );\n\t\t\tmethod.invoke( null, new Object[]{ rti } );\n\t\t} catch ( Exception e ) {\n\t\t\tSystem.err.println( \"Exception caught on unpublish!\" );\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\t/**\n\t* Subscribes federate to the <%=isinteraction?\"interaction\":\"object\"%> class names by \"className\"\n\t* This can also be performed by calling the subscribe( RTIambassador rti )\n\t* method directly on the <%=isinteraction?\"interaction\":\"object\"%> class named by \"className\" (for\n\t* example, to subscribe a federate to the <%=isinteraction?\"Interaction\":\"Object\"%>Root class\n\t* in particular, see {@link <%=isinteraction?\"Interaction\":\"Object\"%>Root#subscribe( RTIambassador rti )}).\n\t*\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class to which to subscribe the federate\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t*/\n\tpublic static void subscribe( String className, RTIambassador rti ) {\n\t\tClass<?> rtiClass = _classNameClassMap.get( className );\n\t\tif ( rtiClass == null ) {\n\t\t\tSystem.err.println( \"Bad class name \\\"\" + className + \"\\\" on subscribe.\" );\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tMethod method = rtiClass.getMethod( \"subscribe\", pubsubArguments );\n\t\t\tmethod.invoke( null, new Object[]{ rti } );\n\t\t} catch ( Exception e ) {\n\t\t\tSystem.err.println( \"Exception caught on subscribe!\" );\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\t/**\n\t* Unsubscribes federate from the <%=isinteraction?\"interaction\":\"object\"%> class names by \"className\"\n\t* This can also be performed by calling the unsubscribe( RTIambassador rti )\n\t* method directly on the <%=isinteraction?\"interaction\":\"object\"%> class named by \"className\" (for\n\t* example, to unsubscribe a federate to the <%=isinteraction?\"Interaction\":\"Object\"%>Root class\n\t* in particular, see {@link <%=isinteraction?\"Interaction\":\"Object\"%>Root#unsubscribe( RTIambassador rti )}).\n\t*\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class to which to unsubscribe the federate\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t*/\n\tpublic static void unsubscribe( String className, RTIambassador rti ) {\n\t\tClass<?> rtiClass = _classNameClassMap.get( className );\n\t\ttry {\n\t\t\tMethod method = rtiClass.getMethod( \"unsubscribe\", pubsubArguments );\n\t\t\tmethod.invoke( null, new Object[]{ rti } );\n\t\t} catch ( Exception e ) {\n\t\t\tSystem.err.println( \"Exception caught on unsubscribe!\" );\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n<% if(isinteraction){ %><%}else{%>\n\t/**\n\t* Publishes the attribute named by \"attributeName\" of the object class named\n\t* by \"className\" for a federate.  This can also be performed by calling the\n\t* publish_<attributeName>() method directly on the object class named by\n\t* \"className\".\n\t*\n\t* Note:  This method only marks the attribute named by \"attributeName\" for\n\t* publication.  The attribute doesn't actually get published until the\n\t* \"className\" object class, of which it is a member, is (re)published.  See\n\t* {@link ObjectRoot#publish( String className, RTIambassador RTI )} and\n\t* {@link ObjectRoot#publish( RTIambassador RTI )} for examples of how to\n\t* publish the object class.\n\t* \n\t* @param className name of object class for which the attribute named by\n\t* \"attributeName\" is to be published\n\t* @param attributeName name of the attribute to be published\n\t*/\n\tpublic static void publish( String className, String attributeName ) {\n\t\ttry {\n\t\t\t_classNamePublishAttributeNameMap.get( className ).add( attributeName );\n\t\t} catch ( Exception e ) {\n\t\t\tSystem.err.println( \"ERROR:  ObjectRoot.publish:  could not publish class \\\"\" + className + \"\\\" \\\"\" + attributeName + \"\\\" attribute.\" );\n\t\t\te.printStackTrace();\n\t\t}\t\t\n\t}\n\n\t/**\n\t* Unpublishes the attribute named by \"attributeName\" of the object class named\n\t* by \"className\" for a federate.  This can also be performed by calling the\n\t* unpublish_<attributeName>() method directly on the object class named by\n\t* \"className\".\n\t*\n\t* Note:  This method only marks the attribute named by \"attributeName\" for\n\t* un-publication. The attribute doesn't actually get unpublished until the\n\t* \"className\" object class, of which it is a member, is (re)published.  See\n\t* {@link ObjectRoot#publish( String className, RTIambassador RTI )} and\n\t* {@link ObjectRoot#publish( RTIambassador RTI )} for examples of how to\n\t* publish the object class.\n\t* \n\t* @param className name of object class for which the attribute named by\n\t* \"attributeName\" is to be unpublished (by a federate)\n\t* @param attributeName name of the attribute to be unpublished\n\t*/\n\tpublic static void unpublish( String className, String attributeName ) {\n\t\ttry {\n\t\t\t_classNamePublishAttributeNameMap.get( className ).remove( attributeName );\n\t\t} catch ( Exception e ) {\n\t\t\tSystem.err.println( \"ERROR:  ObjectRoot.unpublish:  could not unpublish class \\\"\" + className + \"\\\" \\\"\" + attributeName + \"\\\" attribute.\" );\n\t\t\te.printStackTrace();\n\t\t}\t\t\n\t}\n\n\t/**\n\t* Subscribe a federate to the attribute named by \"attributeName\" of the\n\t* object class named by \"className\".  This can also be performed by calling\n\t* the subscribe_<attributeName>() method directly on the object class named\n\t* by \"className\".\n\t*\n\t* Note:  This method only marks the attribute named by \"attributeName\" for\n\t* subscription.  The attribute doesn't actually get subscribed to until the\n\t* \"className\" object class, of which it is a member, is (re)subscribed to.\n\t* See {@link ObjectRoot#subscribe( String className, RTIambassador RTI )} and\n\t* {@link ObjectRoot#subscribe( RTIambassador RTI )} for examples of how to\n\t* subscribe to the object class.\n\t* \n\t* @param className name of object class for which the attribute named by\n\t* \"attributeName\" is to be subcribed\n\t* @param attributeName name of the attribute to be published\n\t*/\n\tpublic static void subscribe( String className, String attributeName ) {\n\t\ttry {\n\t\t\t_classNameSubscribeAttributeNameMap.get( className ).add( attributeName );\n\t\t} catch ( Exception e ) {\n\t\t\tSystem.err.println( \"ERROR:  ObjectRoot.subscribe:  could not subscribe to class \\\"\" + className + \"\\\" \\\"\" + attributeName + \"\\\" attribute.\" );\n\t\t\te.printStackTrace();\n\t\t}\t\t\n\t}\n\n\t/**\n\t* Unsubscribe a federate from the attribute named by \"attributeName\" of the\n\t* object class named by \"className\".  This can also be performed by calling\n\t* the unsubscribe_<attributeName>() method directly on the object class named\n\t* by \"className\".\n\t*\n\t* Note:  This method only marks the attribute named by \"attributeName\" for\n\t* unsubscription.  The attribute doesn't actually get unsubscribed from until the\n\t* \"className\" object class, of which it is a member, is (re)subscribed to.\n\t* See {@link ObjectRoot#subscribe( String className, RTIambassador RTI )} and\n\t* {@link ObjectRoot#subscribe( RTIambassador RTI )} for examples of how to\n\t* subscribe to the object class.\n\t* \n\t* @param className name of object class for which the attribute named by\n\t* \"attributeName\" is to be subcribed\n\t* @param attributeName name of the attribute to be published\n\t*/\n\tpublic static void unsubscribe( String className, String attributeName ) {\n\t\ttry {\n\t\t\t_classNameSubscribeAttributeNameMap.get( className ).remove( attributeName );\n\t\t} catch ( Exception e ) {\n\t\t\tSystem.err.println( \"ERROR:  ObjectRoot.unsubscribe:  could not unsubscribe class \\\"\" + className + \"\\\" \\\"\" + attributeName + \"\\\" attribute.\" );\n\t\t\te.printStackTrace();\n\t\t}\t\t\n\t}\n<%}%>\n\t\n\tprivate static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( Class<?> rtiClass ) {\n\t\t<%=isinteraction?\"Interaction\":\"Object\"%>Root classRoot = null;\n\t\ttry {\n\t\t\tclassRoot = (<%=isinteraction?\"Interaction\":\"Object\"%>Root)rtiClass.newInstance();\n\t\t} catch( Exception e ) {\n\t\t\tSystem.err.println( \"ERROR:  <%=isinteraction?\"Interaction\":\"Object\"%>Root:  create_<%=isinteraction?\"interaction\":\"object\"%>:  could not create/cast new <%=isinteraction?\"Interaction\":\"Object\"%>\" );\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\treturn classRoot;\n\t}\n\n\tprivate static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( Class<?> rtiClass, LogicalTime logicalTime ) {\t\n\t\t<%=isinteraction?\"Interaction\":\"Object\"%>Root classRoot = create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass );\n\t\tif ( classRoot != null ) classRoot.setTime( logicalTime );\n\t\treturn classRoot;\n\t}\n\n\tprivate static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( Class<?> rtiClass, <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap ) {\n\t\t<%=isinteraction?\"Interaction\":\"Object\"%>Root classRoot = create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass );\n\t\tclassRoot.set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\n\t\treturn classRoot;\n\t}\n\t\n\tprivate static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( Class<?> rtiClass, <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime ) {\n\t\t<%=isinteraction?\"Interaction\":\"Object\"%>Root classRoot = create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass );\n\t\tclassRoot.set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\n\t\tclassRoot.setTime( logicalTime );\n\t\treturn classRoot;\n\t}\n\t\n\t/**\n\t* Create an <%=isinteraction?\"interaction\":\"object\"%> that is in instance of <%=isinteraction?\"interaction\":\"object\"%> class\n\t* \"className\". An <%=isinteraction?\"Interaction\":\"Object\"%>Root reference is returned,\n\t* so to refer to the instance using a reference to a \"className\" interaction,\n\t* the returned reference must be cast down the <%=isinteraction?\"interaction\":\"object\"%> inheritance\n\t* hierarchy.\n\t* An instance of the \"className\" <%=isinteraction?\"interaction\":\"object\"%> class may also be created\n\t* by using the \"new\" operator directory on the \"className\" <%=isinteraction?\"interaction\":\"object\"%>\n\t* class.  For instance, two ways to create an <%=isinteraction?\"Interaction\":\"Object\"%>Root\n\t* instance are\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>.create_<%=isinteraction?\"interaction\":\"object\"%>( \"<%=isinteraction?\"Interaction\":\"Object\"%>Root\" ),\n\t* and\n\t* new <%=isinteraction?\"Interaction\":\"Object\"%>Root()\n\t*\n\t* @param className fully-qualified (dot-delimited) name of the <%=isinteraction?\"interaction\":\"object\"%>\n\t* class for which to create an instance\n\t* @return instance of \"className\" <%=isinteraction?\"interaction\":\"object\"%> class\n\t*/\n\tpublic static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( String className ) {\n\t\tClass<?> rtiClass = _classNameClassMap.get( className );\n\t\tif ( rtiClass == null ) return null;\n\n\t\treturn create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass );\n\t}\n\n\t/**\n\t* Like {@link #create_<%=isinteraction?\"interaction\":\"object\"%>( String className )}, but <%=isinteraction?\"interaction\":\"object\"%>\n\t* is created with a timestamp based on \"logicalTime\".\n\t*\n\t* @param className fully-qualified (dot-delimited) name of the <%=isinteraction?\"interaction\":\"object\"%>\n\t* class for which to create an instance\n\t* @param logicalTime timestamp to place on the new <%=isinteraction?\"interaction\":\"object\"%> class instance\n\t* @return instance of \"className\" <%=isinteraction?\"interaction\":\"object\"%> class with \"logicalTime\" time stamp.\n\t*/\n\tpublic static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( String className, LogicalTime logicalTime ) {\n\t\tClass<?> rtiClass = _classNameClassMap.get( className );\n\t\tif ( rtiClass == null ) return null;\n\n\t\treturn create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass, logicalTime );\n\t}\n\n\t/**\n\t* Create an <%=isinteraction?\"interaction\":\"object\"%> that is in instance of <%=isinteraction?\"interaction\":\"object\"%> class\n\t* that corresponds to the \"classHandle\" handle (RTI assigned). An\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>Root reference is returned, so to refer to the\n\t* instance using a reference to a \"className\" interaction, the returned\n\t* reference must be cast down the <%=isinteraction?\"interaction\":\"object\"%> inheritance hierarchy.\n\t*\n\t* @param classHandle handle of <%=isinteraction?\"interaction\":\"object\"%> class (RTI assigned) class for\n\t* which to create an instance\n\t* @return instance of <%=isinteraction?\"interaction\":\"object\"%> class corresponding to \"classHandle\"\n\t*/\n\tpublic static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle ) {\n\t\tClass<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );\n\t\tif ( rtiClass == null ) return null;\n\n\t\treturn create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass );\n\t}\n\n\t/**\n\t* Like {@link #create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle )}, but the <%=isinteraction?\"interaction\":\"object\"%>\n\t* is created with a timestamp based on \"logicalTime\".\n\t*\n\t* @param classHandle handle of <%=isinteraction?\"interaction\":\"object\"%> class (RTI assigned) class for\n\t* which to create an instance\n\t* @param logicalTime timestamp to place on the new <%=isinteraction?\"interaction\":\"object\"%> class instance\n\t* @return instance of <%=isinteraction?\"interaction\":\"object\"%> class corresponding to \"classHandle\" with\n\t* \"logicalTime\" time stamp\n\t*/\n\tpublic static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, LogicalTime logicalTime ) {\n\t\tClass<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );\n\t\tif ( rtiClass == null ) return null;\n\n\t\treturn create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass, logicalTime );\n\t}\n\n\t/**\n\t* Like {@link #create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle )}, but the <%=isinteraction?\"interaction\":\"object\"%>'s\n\t* <%=isinteraction?\"parameter\":\"attribute\"%>s are initialized using \"datamemberMap\".  The \"datamemberMap\"\n\t* is usually acquired as an argument to an RTI callback method of a federate.\n\t*\n\t* @param classHandle handle of <%=isinteraction?\"interaction\":\"object\"%> class (RTI assigned) class for\n\t* which to create an instance\n\t* @param datamemberMap contains initializing values for the <%=isinteraction?\"parameter\":\"attribute\"%>s\n\t* of the <%=isinteraction?\"interaction\":\"object\"%> class instance\n\t* @return instance of <%=isinteraction?\"interaction\":\"object\"%> class corresponding to \"classHandle\" with\n\t* its <%=isinteraction?\"parameter\":\"attribute\"%>s initialized with the \"datamemberMap\"\n\t*/\n\tpublic static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap ) {\n\t\tClass<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );\n\t\tif ( rtiClass == null ) return null;\n\n\t\treturn create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass, datamemberMap );\n\t}\n\n\t/**\n\t* Like {@link #create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap )},\n\t* but the <%=isinteraction?\"interaction\":\"object\"%> is given a timestamp based on \"logicalTime\".\n\t*\n\t* @param classHandle handle of <%=isinteraction?\"interaction\":\"object\"%> class (RTI assigned) class for\n\t* which to create an instance\n\t* @param datamemberMap initializing values for the <%=isinteraction?\"parameter\":\"attribute\"%>s of the\n\t* <%=isinteraction?\"interaction\":\"object\"%> class instance\n\t* @param logicalTime timestamp to place on the new <%=isinteraction?\"interaction\":\"object\"%> class instance\n\t* @return instance of <%=isinteraction?\"interaction\":\"object\"%> class corresponding to \"classHandle\" with\n\t* its <%=isinteraction?\"parameter\":\"attribute\"%>s initialized with the \"datamemberMap\" and with\n\t* \"logicalTime\" timestamp\n\t*/\n\tpublic static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime ) {\n\t\tClass<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );\n\t\tif ( rtiClass == null ) return null;\n\n\t\treturn create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass, datamemberMap, logicalTime );\n\t}\n\n<% if(isinteraction){ %><%}else{%>\n\t/**\n\t* Creates a new instance of the object class corresponding to \"class_handle\",\n\t* registers it in an map internal to the ObjectRoot class using \"object_handle\"\n\t* as a key, and returns a reference to the instance.  Though the created\n\t* instance is of the object class corresponding to \"class_handle\" (which is\n\t* a handle assigned by the RTI), it is referred to, via the return value, by\n\t* an ObjectRoot reference.  Thus, to refer to it as an instance of the object\n\t* class corresponding to \"class_handle\", the ObjectRoot reference needs to be\n\t* cast down through the inheritance hierarchy.\n\t* <p/>\n\t* class_handle and object_handle are usually acquired as arguments of the\n\t* \"discoverObjectInstance\" RTI callback method of a federate.\n\t*\n\t* @param class_handle handle of object class (RTI assigned) for which to create\n\t* an instance\n\t* @param object_handle handle (also RTI assigned) of this instance as it is\n\t* known to the RTI.  Any updates to the instance attributes provided by the\n\t* RTI (via a \"reflectAttributeValues\" federate callback) will be identified\n\t* with this object_handle.\n\t* @return new instance of the object class corresponding to class_handle\n\t*/\n    public static ObjectRoot discover( int class_handle, int object_handle ) {\n        Class<?> hlaObjectClass = _classNameClassMap.get(  _classHandleNameMap.get( class_handle )  );\n        ObjectRoot objectRoot = null;\n        try {\n            objectRoot = (ObjectRoot)hlaObjectClass.newInstance();\n            objectRoot.setObjectHandle( object_handle );\n            _objectMap.put( object_handle, objectRoot );\n        } catch( Exception e ) {\n            System.err.println( \"ERROR:  ObjectRoot:  discover:  could not discover object\" );\n            e.printStackTrace();\n        }\n        return objectRoot;\n    }\n    \n    /**\n    * Retrieves the object instance corresponding to \"object_handle\" from an\n    * internal table in the ObjectRoot class, updates its attribute values using\n    * \"reflectedAttributes\", and returns the instance.  Both \"object_handle\" and\n    * \"reflectedAttributes\" are usually acquired as arguments of the\n    * \"reflectAttributeValues\" RTI callback of a federate.\n    * The return value is an ObjectRoot reference to the instance.  So, to refer\n    * to the instance as an instance of its actual class, this reference will\n    * have to be cast down the inheritance hierarchy.\n    *\n    * @param object_handle handle (RTI assigned) of object instance for which the\n    * attributes are to be updated.\n    * @param reflectedAttributes set of updated values for the attributes of the\n    * object instance corresponding to object_handle.\n    * @return the object instance with updated attribute values\n    */\n    public static ObjectRoot reflect( int object_handle, ReflectedAttributes reflectedAttributes ) {\n    \tObjectRoot objectRoot = _objectMap.get( object_handle );\n    \tif ( objectRoot == null ) return null;\n    \tobjectRoot.setTime( -1 );\n    \tobjectRoot.setAttributes( reflectedAttributes );\n    \treturn objectRoot;\n    }\n\n\t/**\n\t* Like {@link #reflect( int object_handle, ReflectedAttributes reflectedAttributes )},\n\t* except the updated attributes of the object instance have their timestamps\n\t* updated to \"logicalTime\".\n\t*\n    * @param object_handle handle (RTI assigned) of object instance for which the\n    * attributes are to be updated.\n    * @param reflectedAttributes set of updated values for the attributes of the\n    * object instance corresponding to object_handle.\n    * @param logicalTime new time stamp for attributes that are updated\n    * @return the object instance with updated attribute values\n    */\n    public static ObjectRoot reflect( int object_handle, ReflectedAttributes reflectedAttributes, LogicalTime logicalTime ) {\n    \tObjectRoot objectRoot = _objectMap.get( object_handle );\n    \tif ( objectRoot == null ) return null;\n    \tobjectRoot.setTime( logicalTime );\n    \tobjectRoot.setAttributes( reflectedAttributes );\n    \treturn objectRoot;\n    }\n\n\t/**\n\t* Like {@link #reflect( int object_handle, ReflectedAttributes reflectedAttributes )},\n\t* except the updated attributes of the object instance have their timestamps\n\t* updated to \"time\".\n\t*\n    * @param object_handle handle (RTI assigned) of object instance for which the\n    * attributes are to be updated.\n    * @param reflectedAttributes set of updated values for the attributes of the\n    * object instance corresponding to object_handle.\n    * @param time new time stamp for attributes that are updated\n    * @return the object instance with updated attribute values\n    */\n    public static ObjectRoot reflect( int object_handle, ReflectedAttributes reflectedAttributes, double time ) {\n    \tObjectRoot objectRoot = _objectMap.get( object_handle );\n    \tif ( objectRoot == null ) return null;\n    \tobjectRoot.setTime( time );\n    \tobjectRoot.setAttributes( reflectedAttributes );\n    \treturn objectRoot;\n    }\n\n\t/**\n\t* Requests an attribute update for this object instance from the federate that\n\t* has modification rights on these attributes.\n\t*\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t*/\n\tpublic void requestUpdate( RTIambassador rti ) {\n\t\tboolean requestNotSubmitted = true;\n\t\twhile( requestNotSubmitted ) {\n\t\t\ttry {\t\t\n\t\t\t\trti.requestObjectAttributeValueUpdate( getObjectHandle(), getSubscribedAttributeHandleSet() );\n\t\t\t\trequestNotSubmitted = false;\n\t\t\t} catch ( FederateNotExecutionMember f ) {\n\t\t\t\tSystem.err.println( \"ERROR: \" + getClassName() + \"request for update failed:  Federate Not Execution Member\" );\n\t\t\t\tf.printStackTrace();\n\t\t\t\treturn;\t\t\t\t\n\t\t\t} catch ( ObjectNotKnown o ) {\n\t\t\t\tSystem.err.println( \"ERROR: \" + getClassName() + \"request for update failed:  Object Not Known\" );\n\t\t\t\to.printStackTrace();\n\t\t\t\treturn;\t\t\t\t\n\t\t\t} catch ( AttributeNotDefined a ) {\n\t\t\t\tSystem.err.println( \"ERROR: \" + getClassName() + \"request for update failed:  Name Not Found\" );\n\t\t\t\ta.printStackTrace();\n\t\t\t\treturn;\t\t\t\t\n\t\t\t} catch ( Exception e ) {\n\t\t\t\te.printStackTrace();\n\t\t\t\ttry { Thread.sleep( 50 ); } catch( Exception e1 ) { }\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Returns the object instance corresponding to the \"object_handle\" (RTI\n\t* assigned) from a map internal to the ObjectRoot class.\n\t* The object instance is referred to, via the return value, using an\n\t* an ObjectRoot reference.  To reference to it using a reference of its\n\t* actual class, the returned reference must be cast down through the\n\t* inhertance hierarchy.\n\t*\n\t* @param object_handle handle (RTI assigned) of object instance to retrieve\n\t* from the map internal to the ObjectRoot class.\n\t* @return object instance corresponding to the object_handle (RTI assigned)\n\t* in the map that is internal to the ObjectRoot class.\n\t*/\n\tpublic static ObjectRoot getObject( int object_handle ) {\n\t\treturn _objectMap.get( object_handle );\n\t}\n\t\n\t\n\t/**\n\t* Returns the object instance corresponding to the \"object_handle\" (RTI\n\t* assigned) from a map internal to the ObjectRoot class AND REMOVES IT\n\t* FROM THIS MAP.\n\t* The object instance is referred to, via the return value, using an\n\t* an ObjectRoot reference.  To reference to it using a reference of its\n\t* actual class, the returned reference must be cast down through the\n\t* inhertance hierarchy.\n\t*\n\t* @param object_handle handle (RTI assigned) of object instance to retrieve\n\t* from the map internal to the ObjectRoot class.\n\t* @return object instance corresponding to the object_handle (RTI assigned)\n\t* in the map that is internal to the ObjectRoot class.\n\t*/\n    public static ObjectRoot removeObject( int object_handle ) {\n        return _objectMap.remove( object_handle );\n    }\n    \n\n    private int _object_handle;\n\n    private void setObjectHandle( int object_handle ) {\n        _objectMap.remove( object_handle );\n        _object_handle = object_handle;\n        _objectMap.put( object_handle, this );\n    }\n\n\t/**\n\t* Returns the handle (RTI assigned) the corresponds to this object class\n\t* instance.  This handle is the instance's unique identifier to the RTI.\n\t*\n\t* @return the handle (RTI assigned) of this object class instance.\n\t*/\n    public int getObjectHandle() { return _object_handle; }\n\t\n<%}%>\n\n\tprivate double _time = -1;\n\t\n\t/**\n\t* Returns the timestamp for this <%=isinteraction?\"interaction\":\"object\"%>.  \"receive order\" <%=isinteraction?\"interaction\":\"object\"%>s\n\t* should have a timestamp of -1.\n\t*\n\t* @return timestamp for this <%=isinteraction?\"interaction\":\"object\"%>\n\t*/\n\tpublic double getTime() { return _time; }\n\t\n\t/**\n\t* Sets the timestamp of this <%=isinteraction?\"interaction\":\"object\"%> to \"time\".\n\t*\n\t* @param time new timestamp for this <%=isinteraction?\"interaction\":\"object\"%>\n\t*/\n\tpublic void setTime( double time ) { _time = time; }\n\n\t/**\n\t* Sets the timestamp of this <%=isinteraction?\"interaction\":\"object\"%> to \"logicalTime\".\n\t*\n\t* @param logicalTime new timestamp for this <%=isinteraction?\"interaction\":\"object\"%>\n\t*/\n\tpublic void setTime( LogicalTime logicalTime ) {\n\t\tDoubleTime doubleTime = new DoubleTime();\n\t\tdoubleTime.setTo( logicalTime );\n\t\tsetTime( doubleTime.getTime() );\n\t}\n\n\n\t/**\n\t* Creates a new <%=isinteraction?\"Interaction\":\"Object\"%>Root instance.\n\t*/\n\tpublic <%=isinteraction?\"Interaction\":\"Object\"%>Root() {\n\t\t_uniqueID = generateUniqueID();\n\t}\n\t\n\t/**\n\t* Creates a copy of an <%=isinteraction?\"Interaction\":\"Object\"%>Root instance.  As an\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>Root instance contains no <%=isinteraction?\"parameter\":\"attribute\"%>s,\n\t* this has the same effect as the default constructor.\n\t*/\n\tpublic <%=isinteraction?\"Interaction\":\"Object\"%>Root( <%=isinteraction?\"Interaction\":\"Object\"%>Root <%=isinteraction?\"interaction\":\"object\"%>Root ) {\n\t\tthis();\n\t}\n\n\tprotected <%=isinteraction?\"Interaction\":\"Object\"%>Root( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, boolean initFlag ) {\n\t\tthis();\n\t\tif ( initFlag ) set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\n\t}\n\t\n\tprotected <%=isinteraction?\"Interaction\":\"Object\"%>Root( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime, boolean initFlag ) {\n\t\tthis();\n\t\tsetTime( logicalTime );\n\t\tif ( initFlag ) set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\n\t}\n\n\n\t/**\n\t* Creates a new <%=isinteraction?\"interaction\":\"object\"%> instance and initializes its <%=isinteraction?\"parameter\":\"attribute\"%>s\n\t* using the \"datamemberMap\" -- this constructor is usually called as a\n\t* super-class constructor to create and initialize an instance of an\n\t* <%=isinteraction?\"interaction\":\"object\"%> further down in the inheritance hierarchy.  \"datamemberMap\"\n\t* is usually acquired as an argument to an RTI federate callback method, such\n\t* as \"receiveInteraction\".\n\t*\n\t* @param datamemberMap contains <%=isinteraction?\"parameter\":\"attribute\"%> values for the newly created\n\t* <%=isinteraction?\"interaction\":\"object\"%>\n\t*/\n\tpublic <%=isinteraction?\"Interaction\":\"Object\"%>Root( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap ) {\n\t\tthis( datamemberMap, true );\n\t}\n\n\t/**\n\t* Like {@link #<%=isinteraction?\"Interaction\":\"Object\"%>Root( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap )},\n\t* except the new instance has an initial timestamp of \"logicalTime\".\n\t*\n\t* @param datamemberMap contains <%=isinteraction?\"parameter\":\"attribute\"%> values for the newly created\n\t* <%=isinteraction?\"interaction\":\"object\"%>\n\t* @param logicalTime initial timestamp for newly created <%=isinteraction?\"interaction\":\"object\"%> instance\n\t*/\t\n\tpublic <%=isinteraction?\"Interaction\":\"Object\"%>Root( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime ) {\n\t\tthis( datamemberMap, logicalTime, true );\n\t}\n\n\t/**\n\t* Returns the value of the <%=isinteraction?\"parameter\":\"attribute\"%> named \"datamemberName\" for this\n\t* <%=isinteraction?\"interaction\":\"object\"%>.\n\t*\n\t* @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value to retrieve\n\t* @return the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose name is \"datamemberName\"\n\t*/\n\tpublic Object get<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName ) {\n\t\treturn null;\n\t}\n\n\t/**\n\t* Returns the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose handle is \"datamemberHandle\"\n\t* (RTI assigned) for this <%=isinteraction?\"interaction\":\"object\"%>.\n\t*\n\t* @param datamemberHandle handle (RTI assigned) of <%=isinteraction?\"parameter\":\"attribute\"%> whose\n\t* value to retrieve\n\t* @return the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose handle is \"datamemberHandle\"\n\t*/\n\tpublic Object get<%=isinteraction?\"Parameter\":\"Attribute\"%>( int datamemberHandle ) {\n\t\treturn null;\n\t}\n\t\t\n\t/**\n\t* Set the values of the <%=isinteraction?\"parameter\":\"attribute\"%>s in this <%=isinteraction?\"interaction\":\"object\"%> using\n\t* \"datamemberMap\".  \"datamemberMap\" is usually acquired as an argument to\n\t* an RTI federate callback method such as \"receiveInteraction\".\n\t*\n\t* @param datamemberMap  contains new values for the <%=isinteraction?\"parameter\":\"attribute\"%>s of\n\t* this <%=isinteraction?\"interaction\":\"object\"%>\n\t*/\n\tpublic void set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap ) {\n\t\tint size = datamemberMap.size();\n\t\tfor( int ix = 0 ; ix < size ; ++ix ) {\n\t\t\ttry {\n\t\t\t\tset<%=isinteraction?\"Parameter\":\"Attribute\"%>(  datamemberMap.get<%=isinteraction?\"Parameter\":\"Attribute\"%>Handle( ix ), datamemberMap.getValue( ix )  );\n\t\t\t} catch ( Exception e ) {\n\t\t\t\tSystem.err.println( \"set<%=isinteraction?\"Parameter\":\"Attribute\"%>s: Exception caught!\" );\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void set<%=isinteraction?\"Parameter\":\"Attribute\"%>( int handle, byte[] val ) {\n\t\tif ( val == null ) {\n\t\t\tSystem.err.println( \"set:  Attempt to set null value in class \\\"\" + getClass().getName() + \"\\\"\" );\n\t\t}\n\t\tString valAsString = new String( val, 0, val.length );\n\t\tif (valAsString != null && valAsString.length() > 0 && valAsString.charAt(valAsString.length() - 1) == '\\0') {\n\t\t\tvalAsString = valAsString.substring(0, valAsString.length() - 1);\n\t\t}\n\t\tif (   !set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux(  handle, valAsString  )   ) {\n\t\t\tSystem.err.println( \"set:  bad <%=isinteraction?\"parameter\":\"attribute\"%> handle in class \\\"\" + getClass().getName() + \"\\\"\" );\n\t\t}\n\t}\n\t\n\t/**\n\t* Sets the value of the <%=isinteraction?\"parameter\":\"attribute\"%> named \"datamemberName\" to \"value\"\n\t* in this <%=isinteraction?\"interaction\":\"object\"%>.  \"value\" is converted to data type of \"datamemberName\"\n\t* if needed.\n\t* This action can also be affected by calling the set_<datamemberName>( value )\n\t* method on the <%=isinteraction?\"interaction\":\"object\"%> using a reference to the <%=isinteraction?\"interaction\":\"object\"%>'s actual\n\t* class.\n\t*\n\t* @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value is to be set\n\t* to \"value\"\n\t* @param value new value of <%=isinteraction?\"parameter\":\"attribute\"%> called \"datamemberName\"\n\t*/\n\tpublic void set<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName, String value ) {\n\t\tif (  !set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( datamemberName, value )  ) {\n\t\t\tSystem.err.println( \"Error:  <%=isinteraction?\"interaction\":\"object\"%>Root:  invalid <%=isinteraction?\"parameter\":\"attribute\"%> \\\"\" + datamemberName + \"\\\"\" );\n\t\t}\n\t}\n\n\t/**\n\t* Sets the value of the <%=isinteraction?\"parameter\":\"attribute\"%> named \"datamemberName\" to \"value\"\n\t* in this <%=isinteraction?\"interaction\":\"object\"%>.  \"value\" should have the same data type as that of\n\t* the \"datamemberName\" <%=isinteraction?\"parameter\":\"attribute\"%>.\n\t* This action can also be affected by calling the set_<datamemberName>( value )\n\t* method on the <%=isinteraction?\"interaction\":\"object\"%> using a reference to the <%=isinteraction?\"interaction\":\"object\"%>'s actual\n\t* class.\n\t*\n\t* @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value is to be set\n\t* to \"value\"\n\t* @param value new value of <%=isinteraction?\"parameter\":\"attribute\"%> called \"datamemberName\"\n\t*/\n\tpublic void set<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName, Object value ) {\n\t\tif (  !set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( datamemberName, value )  ) {\n\t\t\tSystem.err.println( \"Error:  <%=isinteraction?\"interaction\":\"object\"%>Root:  invalid <%=isinteraction?\"parameter\":\"attribute\"%> \\\"\" + datamemberName + \"\\\"\" );\n\t\t}\n\t}\n\n\tprotected boolean set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( int param_handle, String val ) {\n\t\treturn false;\n\t}\n\n\tprotected boolean set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( String datamemberName, String value ) {\n\t\treturn false;\n\t}\n\n\tprotected boolean set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( String datamemberName, Object value ) {\n\t\treturn false;\n\t}\n\n\tprotected Supplied<%=isinteraction?\"Parameter\":\"Attribute\"%>s createSuppliedDatamembers(<% if(isinteraction){ %><%}else{%>boolean force<%}%>) {\n\t\treturn _factory.createSupplied<%=isinteraction?\"Parameter\":\"Attribute\"%>s();\n\t}\n\t\n<% if(isinteraction){ %>\n\t/**\n\t* Sends this interaction to the RTI, with the specified timestamp \"time\".\n\t* This method should be used to send interactions that have \"timestamp\"\n\t* ordering.\n\t*\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t* @param time timestamp for this interaction.  The timestamp should be no\n\t* less than the current federation time + the LOOKAHEAD value of the federate\n\t* sending this interaction.\n\t*/\n\tpublic void sendInteraction( RTIambassador rti, double time ) throws Exception {\n\t\tsynchronized( rti ) {\n\t\t\ttry {\n\t\t\t\tSuppliedParameters datamembers = createSuppliedDatamembers();\n\t\t\t\trti.sendInteraction(  getClassHandle(), datamembers, null, new DoubleTime( time )  );\n\t\t\t\tcreateLog(datamembers,time);\n\t\t\t} catch ( Exception e ) {\n\t\t\t\tSystem.err.println( \"ERROR:  \" + getClass().getName() + \":  could not send interaction\" );\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Sends this interaction to the RTI (without a timestamp).\n\t* This method should be used to send interactions that have \"receive\"\n\t* ordering.\n\t*\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t*/\n\tpublic void sendInteraction( RTIambassador rti ) throws Exception {\n\t\tsynchronized( rti ) {\n\t\t\ttry {\n\t\t\t\tSuppliedParameters datamembers = createSuppliedDatamembers();\n\t\t\t\trti.sendInteraction( getClassHandle(), datamembers, null );\n\t\t\t\tcreateLog(datamembers,0);\n\t\t\t} catch ( Exception e ) {\n\t\t\t\tSystem.err.println( \"ERROR:  \" + getClass().getName() + \":  could not send interaction\" );\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprotected static String fedName = null;\n\tpublic static Boolean enablePubLog = false;\n\tpublic static Boolean enableSubLog = false;\n\tpublic static String pubLogLevel = null;\n\tpublic static String subLogLevel = null;\n\t\n\tpublic static void enablePublishLog(String interaction, String fed, String thislevel, String globallevel){\n\t\tif(globallevel == null || \"\".equals(globallevel)) return;\n\t\tif(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;\n\t\tfedName = fed;\n\t\tenablePubLog = true;\n\t\tpubLogLevel = thislevel;\n\t\tC2WLogger.addLog(interaction, fedName, true);\n\t}\n\t\n\tpublic static void enableSubscribeLog(String interaction, String fed, String thislevel, String globallevel){\n\t\tif(globallevel == null || \"\".equals(globallevel)) return;\n\t\tif(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;\n\t\tfedName = fed;\n\t\tenableSubLog = true;\n\t\tsubLogLevel = thislevel;\n\t\tC2WLogger.addLog(interaction, fedName, false);\n\t}\n\t\n\tprotected void createLog(final SuppliedParameters datamembers, final double time) {\n\t\tif(!enablePubLog) return;\n        Thread t = new Thread(new Runnable() {                                                                                 // NOMELD\n            public void run() {                                                                                                // NOMELD\n\t\t\t\ttry {\n\t\t\t\t\tString interactionId = fedName != null ? fedName + \"_pub_\"+ getSimpleClassName() :getSimpleClassName() + \"_pub\";\n\n\t\t\t\t\t// First just record the interaction event as a log\n\t\t\t\t\tC2WLogger.addEventLog(time, interactionId);\n\n\t\t\t\t\t// Now, log detailed simulation data of the interaction\n\t\t\t\t\tString logIdLocal = null;\n\t\t\t\t\tsynchronized( <%=isinteraction?\"Interaction\":\"Object\"%>Root.class ) {\n\t\t\t\t\t\tlogIdLocal = Integer.toString( logId++ );\n\t\t\t\t\t}\n\n\t\t\t\t\tint noDatamembers = datamembers.size();\n\t\t\t\t\tif ( noDatamembers == 0 ) {\n\t\t\t\t\t\tC2WLogger.addLog( interactionId, time, null, null, null, pubLogLevel, logIdLocal );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor(int ix =0; ix < datamembers.size();ix++){\n\t\t\t\t\t\t\tString parameter = get_parameter_name(datamembers.getHandle( ix ) );\n\t\t\t\t\t\t\tString value = new String(datamembers.getValue(ix));\t\n\t\t\t\t\t\t\tString type = new String(_datamemberTypeMap.get(parameter));\n\t\t\t\t\t\t\tC2WLogger.addLog( interactionId, time, parameter, value, type, pubLogLevel, logIdLocal );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch ( Exception e ) {\n\t\t\t\t\tSystem.err.println( \"ERROR:  \" + getClass().getName() + \":  could not send interaction\" );\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n            }\n        });\n        t.start();\n\t}\n\n<%}else{%>\n    private boolean _isRegistered = false;\n\n\t/**\n\t* Registers this object with the RTI.  This method is usually called by a\n\t* federate who \"owns\" this object, i.e. the federate that created it and\n\t* has write-privileges to its attributes (so, it is responsible for updating\n\t* these attribute and conveying their updated values to the RTI).\n\t*\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t*/ \n    public void registerObject( RTIambassador rti ) {\n        \n        while( !_isRegistered ) {\n            try {\n                synchronized( rti ) {\n                    _object_handle = rti.registerObjectInstance( getClassHandle() );\n                }\n                _isRegistered = true;\n                _objectMap.put( getObjectHandle(), this );\n                \n            } catch ( ObjectClassNotDefined o ) {\n                o.printStackTrace();\n                return;\n            } catch ( ObjectClassNotPublished o ) {\n                o.printStackTrace();\n                return;\n            } catch ( FederateNotExecutionMember f ) {\n                f.printStackTrace();\n                return;\n            } catch ( Exception e ) {\n                try {\n                    Thread.sleep( 500 );\n                } catch ( InterruptedException e1 ) {\n                    e1.printStackTrace();\n                } \n            }\n        }\n\n    }\n    \n\t/**\n\t* Unregisters this object with the RTI.  The RTI will destroy all information\n\t* it contains regarding this object as a result.  This method is usually\n\t* called by a federate who \"owns\" this object, i.e. the federate that created\n\t* it and has write-privileges to its attributes.\n\t*\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t*/ \n    public void unregisterObject( RTIambassador rti ) {\n        \n        while( _isRegistered ) {\n            try {\n                synchronized( rti ) {\n                    rti.deleteObjectInstance( _object_handle, null );\n                }\n                _isRegistered = false;\n                _objectMap.remove( getObjectHandle() );\n                \n            } catch ( ObjectNotKnown o ) {\n                o.printStackTrace();\n                return;\n            } catch ( DeletePrivilegeNotHeld d ) {\n                d.printStackTrace();\n                return;\n            } catch ( FederateNotExecutionMember f ) {\n                f.printStackTrace();\n                return;\n            } catch ( Exception e ) {\n                try {\n                    Thread.sleep( 500 );\n                } catch ( InterruptedException e1 ) {\n                    e1.printStackTrace();\n                } \n            }\n        }\n    }\n\n\t/**\n\t* Broadcasts the attributes of this object and their values to the RTI, where\n\t* the values have \"time\" as their timestamp.  This call should be used for\n\t* objects whose attributes have \"timestamp\" ordering.\n\t*\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t* @param time timestamp on attribute values of this object\n\t* @param force if \"false\", only the attributes whose values have changed since\n\t* the last call to \"updateAttributeValues\" will be broadcast to the RTI.  If\n\t* \"true\", all attributes and their values are broadcast to the RTI.\n\t*/\n    public void updateAttributeValues( RTIambassador rti, double time, boolean force ) {\n\n        SuppliedAttributes suppliedAttributes = createSuppliedDatamembers( force );\n        if ( suppliedAttributes.size() == 0 ) return;\n\n        synchronized( rti ) {\n            try {\n                rti.updateAttributeValues(  getObjectHandle(), suppliedAttributes, null, new DoubleTime( time )  );\n                createLog(suppliedAttributes, time);\n            } catch ( ObjectNotKnown o ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Object Not Known\" );\n                o.printStackTrace();\n                return;\n            } catch ( FederateNotExecutionMember f ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Federate Not Execution Member\" );\n                f.printStackTrace();\n                return;\n            } catch ( AttributeNotDefined a ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Attribute Not Defined\" );\n                a.printStackTrace();\n                return;\n            } catch ( AttributeNotOwned a ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Attribute Not Owned\" );\n                a.printStackTrace();\n                return;\n            } catch ( ConcurrentAccessAttempted c ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Concurrent Access Attempted\" );\n                c.printStackTrace();\n                return;\n            } catch ( InvalidFederationTime i ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Invalid Federation Time\" );\n                i.printStackTrace();\n                return;\n            } catch ( Exception e ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes\" );\n                e.printStackTrace();\n            }\n        }\n    }\n\n\t/**\n    * Like {@link #updateAttributeValues( RTIambassador rti, double time, boolean force )},\n    * except \"force\" is always false.\n\t*\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t* @param time timestamp on attribute values of this object\n\t*/\n    public void updateAttributeValues( RTIambassador rti, double time ) {\n    \tupdateAttributeValues( rti, time, false );\n    }\n\n\t/**\n\t* Broadcasts the attributes of this object and their values to the RTI (with\n\t* no timestamp).  This call should be used for objects whose attributes have\n\t* \"receive\" ordering.\n\t*\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t* @param force if \"false\", only the attributes whose values have changed since\n\t* the last call to \"updateAttributeValues\" will be broadcast to the RTI.  If\n\t* \"true\", all attributes and their values are broadcast to the RTI.\n\t*/\n    public void updateAttributeValues( RTIambassador rti, boolean force ) {\n\n        SuppliedAttributes suppliedAttributes = createSuppliedDatamembers( force );\n        if ( suppliedAttributes.size() == 0 ) return;\n\n        synchronized( rti ) {\n            try {\n                rti.updateAttributeValues( getObjectHandle(), suppliedAttributes, null );\n                createLog(suppliedAttributes, 0);\n            } catch ( ObjectNotKnown o ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Object Not Known\" );\n                o.printStackTrace();\n                return;\n            } catch ( FederateNotExecutionMember f ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Federate Not Execution Member\" );\n                f.printStackTrace();\n                return;\n            } catch ( AttributeNotDefined a ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Attribute Not Defined\" );\n                a.printStackTrace();\n                return;\n            } catch ( AttributeNotOwned a ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Attribute Not Owned\" );\n                a.printStackTrace();\n                return;\n            } catch ( ConcurrentAccessAttempted c ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Concurrent Access Attempted\" );\n                c.printStackTrace();\n                return;\n            } catch ( Exception e ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes\" );\n                e.printStackTrace();\n            }\n        }\n    }\n\n\t/**\n    * Like {@link #updateAttributeValues( RTIambassador rti, boolean force )},\n    * except \"force\" is always false.\n\t*\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t*/\n\tpublic void updateAttributeValues( RTIambassador rti ) {\n\t\tupdateAttributeValues( rti, false );\n\t}\n\n\tprotected static String _fedName = null;\n\tprotected static Map< String, String > _pubAttributeLogMap = new HashMap< String, String >();\n\tprotected static Map< String, String > _subAttributeLogMap = new HashMap< String, String >();\n\t\n\tpublic static void enablePublishLog(String object, String attribute, String fed, String thislevel, String globallevel){\n\t\tif(globallevel == null || \"\".equals(globallevel)) return;\n\t\tif(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;\n\t\t_fedName = fed;\n\t\t_pubAttributeLogMap.put(attribute, thislevel);\n\t\tC2WLogger.addLog(object, attribute, fed, true);\n\t}\n\t\n\tpublic static void enableSubscribeLog(String object, String attribute, String fed, String thislevel, String globallevel){\n\t\tif(globallevel == null || \"\".equals(globallevel)) return;\n\t\tif(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;\n\t\t_fedName = fed;\n\t\t_subAttributeLogMap.put(attribute, thislevel);\n\t\tC2WLogger.addLog(object, attribute, fed, true);\n\t}\n\t\n\tprotected void createLog(final SuppliedAttributes suppliedAttributes, final double time) {\n\t\tif(_pubAttributeLogMap.isEmpty()) return;\n        Thread t = new Thread(new Runnable() {                                                       // NOMELD\n            public void run() {                                                                      // NOMELD\n\t\t\t\ttry {\n\t\t\t\t\tString eventName = _fedName+\"_pub_\"+getSimpleClassName();\n\n\t\t\t\t\t// First just record the interaction event as a log\n\t\t\t\t\tC2WLogger.addEventLog(time, eventName);\n\n\t\t\t\t\t// Now, log detailed simulation data of the object update\n\t\t\t\t\tString logIdLocal = null;\n\t\t\t\t\tsynchronized( <%=isinteraction?\"Interaction\":\"Object\"%>Root.class ) {\n\t\t\t\t\t\tlogIdLocal = Integer.toString( logId++ );\n\t\t\t\t\t}\n\t\t\t\t\tfor(int ix =0; ix < suppliedAttributes.size();ix++){\t\t\t\t\t\t\t\n\t\t\t\t\t\tString attribute = get_attribute_name(suppliedAttributes.getHandle( ix ) );\t\t\t\n\t\t\t\t\t\tif(!_pubAttributeLogMap.containsKey(attribute)) continue;\n\t\t\t\t\t\tString id = _fedName+\"_pub_\"+getSimpleClassName()+\"_\"+attribute;\n\t\t\t\t\t\tString value = new String(suppliedAttributes.getValue(ix));\t\n\t\t\t\t\t\tString type = new String(_datamemberTypeMap.get(attribute));\n\t\t\t\t\t\tString loglevel = _pubAttributeLogMap.get(attribute);\n\t\t\t\t\t\tC2WLogger.addLog( id, time, attribute, value, type, loglevel, logIdLocal );\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} catch ( Exception e ) {\n\t\t\t\t\tSystem.err.println( \"ERROR:  \" + getClass().getName() + \":  could not send interaction\" );\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n            }\n        });\n        t.start();\n\t}\n\t\n<%}%>\n\n\t/**\n\t* For use with the melding API -- this method is used to cast\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>Root instance reference into the\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface interface.\n\t*\n\t* @param rootInstance <%=isinteraction?\"Interaction\":\"Object\"%>Root instance reference to be\n\t* cast into the <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface interface\n\t* @return <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface reference to the instance\n\t*/\n\tpublic <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface cast( <%=isinteraction?\"Interaction\":\"Object\"%>Root rootInstance ) {\n\t\treturn rootInstance;\n\t}\t\t\n\n\t/**\n\t* For use with the melding API -- this method creates a new\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>Root instance and returns a\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface reference to it.\n\t*\n\t* @return <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface reference to a newly created\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>Root instance\n\t*/\n\tpublic <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface create() {\n\t\treturn new <%=isinteraction?\"Interaction\":\"Object\"%>Root();\n\t}\t\t\n\n\tpublic void copyFrom( Object object ) { }\n}\n",
    "java/federate-config.json.ejs": "{\n  \"federateRTIInitWaitTimeMs\": 200,\n  \"federateType\": \"<%=classname%>\",\n  \"federationId\": \"<%=projectName%>\",\n  \"isLateJoiner\": false,\n  \"lookAhead\": <%=lookahead%>,\n  \"stepSize\": <%=step%>\n}\n",
    "java/federate.java.ejs": "<%/* group federate;\n\nfederate(\n\tsimname,\n\tmelderpackagename,\n\tclassname,\n\tisnonmapperfed,\n\ttimeconstrained,\n\ttimeregulating,\n\tasynchronousdelivery,\n\tpublishedinteractiondata,\n\tsubscribedinteractiondata,\n\tallinteractiondata,\n\tpublishedobjectdata,\n\tsubscribedobjectdata,\n\tallobjectdata\n) ::= <<*/ -%>\n\npackage <%= simname %>;\n\nimport hla.rti.EventRetractionHandle;\nimport hla.rti.LogicalTime;\nimport hla.rti.ReceivedInteraction;\n\nimport org.cpswt.hla.C2WInteractionRoot;\nimport org.cpswt.hla.InteractionRoot;\nimport org.cpswt.hla.SubscribedInteractionFilter;\nimport org.cpswt.hla.SynchronizedFederate;\n\nimport org.cpswt.config.FederateConfig;\n\nimport org.cpswt.hla.*;\n<% if(melderpackagename){ -%>\nimport <%= melderpackagename %>.<%= classname %>;\nimport <%= melderpackagename %>.<%= classname %>RTIFactory;\n<% } -%>\n\npublic class <%= classname %>Base extends <% if(melderpackagename) { %><%= classname %><% }else{ %>SynchronizedFederate<% } %> {\n\n<% if(melderpackagename){ -%>\n\tstatic {\n\t\t<%= classname %>RTIFactory rtiFactory = new <%= classname %>RTIFactory();\n<% /*allinteractiondata:setfactoryvar()*/ -%>\n\t\t<% allinteractiondata.forEach(function(rticlass){ %>\n\t\trtiFactory.set_<%= rticlass.name %>Interface( new <%= rticlass.name %>Melder() );<%});%>\n<% /*allobjectdata:setfactoryvar()*/ -%>\n\t\t<% allobjectdata.forEach(function(rticlass){ %>\n\t\trtiFactory.set_<%= rticlass.name %>Interface( new <%= rticlass.name %>Melder() );<%});%>\t\n\n\t\t<%= classname %>.set<%= classname %>RTIFactory( rtiFactory );\n\t}\n<% } -%>\n\tprivate SubscribedInteractionFilter _subscribedInteractionFilter = new SubscribedInteractionFilter();\n\t\n\t// constructor\n\tpublic <%= classname %>Base(FederateConfig config) throws Exception {\n\t\tsuper(config);\n\n\t\tsuper.createLRC();\n\t\tsuper.joinFederation();\n\n<% if(timeconstrained){ -%>\n\t\tenableTimeConstrained();\n<% } %>\n<% if(timeregulating){ -%>\n\t\tenableTimeRegulation(getLookAhead());\n<% } -%>\n<% if(asynchronousdelivery){ -%>\n\t\tenableAsynchronousDelivery();\n<% } -%>\n        // interaction pubsub\n<% /* publishedinteractiondata:pubinter() */ -%>\n        <% publishedinteractiondata.forEach(function(interactiondata){ %>\n        <%= interactiondata.name %>.publish(getLRC());<%});%>\n<% /* subscribedinteractiondata:subinter() */ -%>\n        <% subscribedinteractiondata.forEach(function(interactiondata){ %>\n        <%= interactiondata.name %>.subscribe(getLRC());\n        _subscribedInteractionFilter.setFedFilters( \n\t\t\t<%= interactiondata.name %>.get_handle(), \n\t\t\tSubscribedInteractionFilter.OriginFedFilter.<%= interactiondata.originFedFilter() %>, \n\t\t\tSubscribedInteractionFilter.SourceFedFilter.<%= interactiondata.srcFedFilter() %> \n\t\t);<%}); -%>\n\t\t\n\t\t// object pubsub\n<%/* publishedobjectdata:pubobjectdata() */ -%>\n        <% publishedobjectdata.forEach(function(objectdata){ %>\n        \t<% objectdata.publishedAttributeData.forEach(function(a){ %>\n        <%= objectdata.name %>.publish_<%= a.name %>();<%});%>\n        <%= objectdata.name %>.publish(getLRC());\n        <%}); -%>\n<%/* subscribedobjectdata:subobjectdata() */ -%>\n        <% subscribedobjectdata.forEach(function(objectdata){ %>\n        \t<% objectdata.subscribedAttributeData.forEach(function(a){ %>\n        <%= objectdata.name %>.subscribe_<%= a.name %>();<%});%>\n        <%= objectdata.name %>.subscribe(getLRC());\n        <%}); -%>\n        }\n        \n<%/* publishedinteractiondata:create_interaction() */ -%>\n\t<%publishedinteractiondata.forEach(function(interaction_data){%>\n\tpublic <%= interaction_data.name %> create_<%= interaction_data.name %>() {\n\t   <%= interaction_data.name%> interaction = new <%= interaction_data.name %>();\n\t   interaction.set_sourceFed( getFederateId() );\n\t   interaction.set_originFed( getFederateId() );\n\t   return interaction;\n\t}<%}); %>\n<%/* filter_interaction() */ -%>\n\t@Override\n\tpublic void receiveInteraction(\n\t int interactionClass, ReceivedInteraction theInteraction, byte[] userSuppliedTag\n\t) {\n\t\tInteractionRoot interactionRoot = InteractionRoot.create_interaction( interactionClass, theInteraction );\n\t\tif ( interactionRoot instanceof C2WInteractionRoot ) {\n\t\t\t\n\t\t\tC2WInteractionRoot c2wInteractionRoot = (C2WInteractionRoot)interactionRoot;\n\n\t        // Filter interaction if src/origin fed requirements (if any) are not met\n\t        if (  _subscribedInteractionFilter.filterC2WInteraction( getFederateId(), c2wInteractionRoot )  ) {\n\t        \treturn;\n\t        } \n\t\t}\n\t\t\n\t\tsuper.receiveInteraction( interactionClass, theInteraction, userSuppliedTag );\t\t\t\n\t}\n\n\t@Override\n\tpublic void receiveInteraction(\n\t int interactionClass,\n\t ReceivedInteraction theInteraction,\n\t byte[] userSuppliedTag,\n\t LogicalTime theTime,\n\t EventRetractionHandle retractionHandle\n\t) {\n\t\tInteractionRoot interactionRoot = InteractionRoot.create_interaction( interactionClass, theInteraction, theTime );\n\t\tif ( interactionRoot instanceof C2WInteractionRoot ) {\n\n\t\t\tC2WInteractionRoot c2wInteractionRoot = (C2WInteractionRoot)interactionRoot;\n\n\t        // Filter interaction if src/origin fed requirements (if any) are not met\n\t        if (  _subscribedInteractionFilter.filterC2WInteraction( getFederateId(), c2wInteractionRoot )  ) {\n\t        \treturn;\n\t        } \n\t\t}\n\n\t\tsuper.receiveInteraction( interactionClass, theInteraction, userSuppliedTag, theTime, retractionHandle );\t\t\t\n\t}\n}\n",
    "java/federatebase.java.ejs": "<%/* group federate;\n\nfederate(\n        simname,\n        melderpackagename,\n        classname,\n        isnonmapperfed,\n        timeconstrained,\n        timeregulating,\n        asynchronousdelivery,\n        publishedinteractiondata,\n        subscribedinteractiondata,\n        allinteractiondata,\n        publishedobjectdata,\n        subscribedobjectdata,\n        allobjectdata\n) ::= <<\n*/ -%>\npackage <%= groupId %>.<%= classname.toLowerCase() %>;\n\n<% if(publishedinteractiondata.length || subscribedinteractiondata.length || publishedobjectdata.length || subscribedobjectdata.length) { -%>\nimport <%= groupId %>.<%= classname.toLowerCase() %>.rti.*;\n<% } -%>\n\nimport hla.rti.EventRetractionHandle;\nimport hla.rti.LogicalTime;\nimport hla.rti.ReceivedInteraction;\n\nimport org.cpswt.hla.C2WInteractionRoot;\nimport org.cpswt.hla.InteractionRoot;\nimport org.cpswt.hla.SubscribedInteractionFilter;\nimport org.cpswt.hla.SynchronizedFederate;\n\nimport org.cpswt.config.FederateConfig;\nimport org.cpswt.utils.CpswtDefaults;\n\nimport org.cpswt.*;\n\n<% if(melderpackagename){ -%>\nimport <%= melderpackagename %>.<%= classname %>;\nimport <%= melderpackagename %>.<%= classname %>RTIFactory;\n<% } -%>\n\npublic class <%= classname %>Base extends <% if(melderpackagename) { %><%= classname %><% }else{ %>SynchronizedFederate<% } %> {\n<% if(melderpackagename){ -%>\n        static {\n                <%= classname %>RTIFactory rtiFactory = new <%= classname %>RTIFactory();\n<% /*allinteractiondata:setfactoryvar()*/ -%>\n                <% allinteractiondata.forEach(function(rticlass){ %>\n                rtiFactory.set_<%= rticlass.name %>Interface( new <%= rticlass.name %>Melder() );<%});%>\n<% /*allobjectdata:setfactoryvar()*/ -%>\n                <% allobjectdata.forEach(function(rticlass){ %>\n                rtiFactory.set_<%= rticlass.name %>Interface( new <%= rticlass.name %>Melder() );<%});%>\n\n                <%= classname %>.set<%= classname %>RTIFactory( rtiFactory );\n        }\n<% } -%>\n    private SubscribedInteractionFilter _subscribedInteractionFilter =\n        new SubscribedInteractionFilter();\n\n    // constructor\n    public <%= classname %>Base(FederateConfig config) throws Exception {\n        super(config);\n        super.createLRC();\n        super.joinFederation();\n<% if(timeconstrained){ -%>\n        enableTimeConstrained();\n<% } -%>\n<% if(timeregulating){ -%>\n        enableTimeRegulation(getLookAhead());\n<% } -%>\n<% if(asynchronousdelivery){ -%>\n        enableAsynchronousDelivery();\n<% } -%>\n\n        // interaction pubsub\n<% /* publishedinteractiondata:pubinter() */ -%>\n<% publishedinteractiondata.forEach(function(interactiondata){ -%>\n        <%= interactiondata.name %>.publish(getLRC());\n<% }); -%>\n<% /* subscribedinteractiondata:subinter() */ -%>\n<% subscribedinteractiondata.forEach(function(interactiondata){ -%>\n        <%= interactiondata.name %>.subscribe(getLRC());\n        _subscribedInteractionFilter.setFedFilters( \n           <%= interactiondata.name %>.get_handle(),\n           SubscribedInteractionFilter.OriginFedFilter.<%= interactiondata.originFedFilter() %>,\n           SubscribedInteractionFilter.SourceFedFilter.<%= interactiondata.srcFedFilter() %>);\n<% }); -%>\n\n        // object pubsub\n<%/* publishedobjectdata:pubobjectdata() */ -%>\n<% publishedobjectdata.forEach(function(objectdata){ -%>\n<% objectdata.publishedAttributeData.forEach(function(a){ -%>\n        <%= objectdata.name %>.publish_<%= a.name %>();\n<% }); -%>\n        <%= objectdata.name %>.publish(getLRC());\n<% }); -%>\n<%/* subscribedobjectdata:subobjectdata() */ -%>\n<% subscribedobjectdata.forEach(function(objectdata){ -%>\n<% objectdata.subscribedAttributeData.forEach(function(a){ -%>\n        <%= objectdata.name %>.subscribe_<%= a.name %>();\n<% }); -%>\n        <%= objectdata.name %>.subscribe(getLRC());\n<% }); -%>\n    }\n\n<%/* publishedinteractiondata:create_interaction() */ -%>\n<%publishedinteractiondata.forEach(function(interaction_data){ -%>\n    public <%= interaction_data.name %> create_<%= interaction_data.name %>() {\n        <%= interaction_data.name%> interaction = new <%= interaction_data.name %>();\n        interaction.set_sourceFed(getFederateId());\n        interaction.set_originFed(getFederateId());\n        return interaction;\n    }\n<% }); -%>\n\n<%/* filter_interaction() */ -%>\n    @Override\n    public void receiveInteraction(int interactionClass,\n                                   ReceivedInteraction theInteraction,\n                                   byte[] userSuppliedTag) {\n        InteractionRoot interactionRoot =\n            InteractionRoot.create_interaction(interactionClass,\n                                               theInteraction);\n        if (interactionRoot instanceof C2WInteractionRoot) {\n            C2WInteractionRoot c2wInteractionRoot =\n                (C2WInteractionRoot)interactionRoot;\n\n            // Filter interaction if src/origin fed requirements (if any)\n            // are not met\n            if (_subscribedInteractionFilter.filterC2WInteraction\n                (getFederateId(), c2wInteractionRoot)) {\n                return;\n            }\n        }\n        super.receiveInteraction(interactionClass, theInteraction,\n                                 userSuppliedTag);\n    }\n\n    @Override\n    public void receiveInteraction(int interactionClass,\n                                   ReceivedInteraction theInteraction,\n                                   byte[] userSuppliedTag,\n                                   LogicalTime theTime,\n                                   EventRetractionHandle retractionHandle) {\n        InteractionRoot interactionRoot =\n            InteractionRoot.create_interaction(interactionClass,\n                                               theInteraction, theTime);\n        if (interactionRoot instanceof C2WInteractionRoot) {\n            C2WInteractionRoot c2wInteractionRoot =\n                (C2WInteractionRoot)interactionRoot;\n\n            // Filter interaction if src/origin fed requirements (if any)\n            // are not met\n            if (_subscribedInteractionFilter.filterC2WInteraction\n                (getFederateId(), c2wInteractionRoot)) {\n                return;\n            }\n        }\n        super.receiveInteraction(interactionClass, theInteraction,\n                                 userSuppliedTag, theTime, retractionHandle);\n    }\n}\n",
    "java/federateimpl.java.ejs": "package <%= groupId %>.<%= classname.toLowerCase() %>;\n\n<% if(publishedinteractiondata.length || subscribedinteractiondata.length || publishedobjectdata.length || subscribedobjectdata.length) { -%>\nimport <%= groupId %>.<%= classname.toLowerCase() %>.rti.*;\n<% } -%>\n\nimport org.cpswt.config.FederateConfig;\nimport org.cpswt.config.FederateConfigParser;\n<%if (subscribedobjectdata.length > 0) { -%>\nimport org.cpswt.hla.base.ObjectReflector;\nimport org.cpswt.hla.ObjectRoot;\n<% } -%>\n<% if (subscribedinteractiondata.length > 0) { -%>\nimport org.cpswt.hla.InteractionRoot;\n<% } -%>\nimport org.cpswt.hla.base.AdvanceTimeRequest;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\n// Define the <%= classname %> type of federate for the federation.\n\npublic class <%= classname %> extends <%= classname %>Base {\n    private final static Logger log = LogManager.getLogger();\n\n    private double currentTime = 0;\n<% if (publishedobjectdata.length > 0) { -%>\n\n    ////////////////////////////////////////////////////////////////////////\n    // TODO instantiate objects that must be sent every logical time step //\n    ////////////////////////////////////////////////////////////////////////\n<% publishedobjectdata.forEach(function(object_data){ -%>\n    // <%=object_data.name%> v<%=object_data.name%> =\n    //     new <%=object_data.name%>();\n<% }); -%>\n<% } -%>\n\n    public <%= classname %>(FederateConfig params) throws Exception {\n        super(params);\n<% if (publishedobjectdata.length > 0) { -%>\n\n        //////////////////////////////////////////////////////\n        // TODO register object instances after super(args) //\n        //////////////////////////////////////////////////////\n<% publishedobjectdata.forEach(function(object_data){ -%>\n        // v<%=object_data.name%>.registerObject(getLRC());\n<% }); -%>\n<% } -%>\n    }\n<% if (subscribedinteractiondata.length + subscribedobjectdata.length > 0) { -%>\n<% var conditional = \"if\"; -%>\n\n    private void checkReceivedSubscriptions() {\n<% if (subscribedinteractiondata.length > 0) { -%>\n<% conditional = \"if\"; -%>\n        InteractionRoot interaction = null;\n        while ((interaction = getNextInteractionNoWait()) != null) {\n<% (subscribedinteractiondata.sort(function(a, b){return b.fullName.length-a.fullName.length})).forEach(function(interaction_data){ -%>\n            <%= conditional %> (interaction instanceof <%= interaction_data.name %>) {\n                handleInteractionClass((<%= interaction_data.name %>) interaction);\n            }\n<% conditional = \"else if\"; -%>\n<% }); -%>\n            else {\n                log.debug(\"unhandled interaction: {}\", interaction.getClassName());\n            }\n        }\n<% } -%>\n<%if (subscribedobjectdata.length > 0) { -%>\n<% conditional = \"if\"; -%>\n\n        ObjectReflector reflector = null;\n        while ((reflector = getNextObjectReflectorNoWait()) != null) {\n            reflector.reflect();\n            ObjectRoot object = reflector.getObjectRoot();\n<% (subscribedobjectdata.sort(function(a, b){return b.fullName.length-a.fullName.length})).forEach(function(object_data){ -%>\n            <%= conditional %> (object instanceof <%= object_data.name %>) {\n                handleObjectClass((<%= object_data.name %>) object);\n            }\n<% conditional = \"else if\"; -%>\n<%}) -%>\n            else {\n                log.debug(\"unhandled object reflection: {}\", object.getClassName());\n            }\n        }\n<% } -%>\n    }\n<% } -%>\n\n    private void execute() throws Exception {\n        if(super.isLateJoiner()) {\n            log.info(\"turning off time regulation (late joiner)\");\n            currentTime = super.getLBTS() - super.getLookAhead();\n            super.disableTimeRegulation();\n        }\n\n        /////////////////////////////////////////////\n        // TODO perform basic initialization below //\n        /////////////////////////////////////////////\n\n        AdvanceTimeRequest atr = new AdvanceTimeRequest(currentTime);\n        putAdvanceTimeRequest(atr);\n\n        if(!super.isLateJoiner()) {\n            log.info(\"waiting on readyToPopulate...\");\n            readyToPopulate();\n            log.info(\"...synchronized on readyToPopulate\");\n        }\n\n        ///////////////////////////////////////////////////////////////////////\n        // TODO perform initialization that depends on other federates below //\n        ///////////////////////////////////////////////////////////////////////\n\n        if(!super.isLateJoiner()) {\n            log.info(\"waiting on readyToRun...\");\n            readyToRun();\n            log.info(\"...synchronized on readyToRun\");\n        }\n\n        startAdvanceTimeThread();\n        log.info(\"started logical time progression\");\n\n        while (!exitCondition) {\n            atr.requestSyncStart();\n            enteredTimeGrantedState();\n<% if (publishedinteractiondata.length > 0) { -%>\n\n            ////////////////////////////////////////////////////////////\n            // TODO send interactions that must be sent every logical //\n            // time step below                                        //\n            ////////////////////////////////////////////////////////////\n\n            // Set the interaction's parameters.\n            //\n<% publishedinteractiondata.forEach(function(interaction_data){ -%>\n            //    <%= interaction_data.name %> v<%= interaction_data.name %> = create_<%= interaction_data.name %>();\n<% interaction_data.parameters.forEach(function(parameter) { -%>\n            //    v<%= interaction_data.name %>.set_<%= parameter.name %>( < YOUR VALUE HERE > );\n<% }) -%>\n            //    v<%= interaction_data.name %>.sendInteraction(getLRC(), currentTime + getLookAhead());\n<% }) -%>\n<% } -%>\n<% if (publishedobjectdata.length > 0) { -%>\n\n            ////////////////////////////////////////////////////////////\n            // TODO objects that must be sent every logical time step //\n            ////////////////////////////////////////////////////////////\n<% publishedobjectdata.forEach(function(object_data){ -%>\n<% if (object_data.parameters.length > 0) { -%>\n<% object_data.parameters.forEach(function(parameter) { -%>\n            //    v<%= object_data.name %>.set_<%= parameter.name %>(<YOUR VALUE HERE >);\n<% }) -%>\n<% } -%>\n            //    v<%= object_data.name %>.updateAttributeValues(getLRC(), currentTime + getLookAhead());\n<% }) -%>\n<% } -%>\n<% if (subscribedinteractiondata.length + subscribedobjectdata.length > 0) { -%>\n\n            checkReceivedSubscriptions();\n<% } -%>\n\n            ////////////////////////////////////////////////////////////////////\n            // TODO break here if ready to resign and break out of while loop //\n            ////////////////////////////////////////////////////////////////////\n\n            if (!exitCondition) {\n                currentTime += super.getStepSize();\n                AdvanceTimeRequest newATR =\n                    new AdvanceTimeRequest(currentTime);\n                putAdvanceTimeRequest(newATR);\n                atr.requestSyncEnd();\n                atr = newATR;\n            }\n        }\n\n        // call exitGracefully to shut down federate\n        exitGracefully();\n\n        //////////////////////////////////////////////////////////////////////\n        // TODO Perform whatever cleanups are needed before exiting the app //\n        //////////////////////////////////////////////////////////////////////\n    }\n<%/* allinteractiondata:createInteraction() */ -%>\n<%subscribedinteractiondata.forEach(function(interaction_data){ -%>\n\n    private void handleInteractionClass(<%= interaction_data.name %> interaction) {\n        ///////////////////////////////////////////////////////////////\n        // TODO implement how to handle reception of the interaction //\n        ///////////////////////////////////////////////////////////////\n    }\n<%}); -%>\n<%/* allobjectdata:createObject() */ -%>\n<%subscribedobjectdata.forEach(function(object_data){ -%>\n\n    private void handleObjectClass(<%= object_data.name %> object) {\n        //////////////////////////////////////////////////////////\n        // TODO implement how to handle reception of the object //\n        //////////////////////////////////////////////////////////\n    }\n<%}); -%>\n\n    public static void main(String[] args) {\n        try {\n            FederateConfigParser federateConfigParser =\n                new FederateConfigParser();\n            FederateConfig federateConfig =\n                federateConfigParser.parseArgs(args, FederateConfig.class);\n            <%= classname %> federate =\n                new <%= classname %>(federateConfig);\n            federate.execute();\n            log.info(\"Done.\");\n            System.exit(0);\n        }\n        catch (Exception e) {\n            log.error(e);\n            System.exit(1);\n        }\n    }\n}\n",
    "java/federateimpl_uberpom.xml.ejs": "<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\n    <modelVersion>4.0.0</modelVersion>\n    <groupId><%= groupId + \".\" + classname.toLowerCase() %></groupId>\n    <artifactId><%= classname %></artifactId>\n    <version><%= projectVersion %></version>\n    <packaging>jar</packaging>\n\n    <properties>\n        <federation.name><%= projectName %></federation.name>\n        <package.name><%= groupId + \".\" + classname.toLowerCase() %></package.name>\n        <federate.name><%= classname %></federate.name>\n        <federation.version><%= projectVersion %></federation.version>\n        <cpswt.version><%= cpswtVersion %></cpswt.version>\n        <nar.version>3.3.0</nar.version>\n        <configFile><%= configFile %></configFile>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.cpswt</groupId>\n            <artifactId>federate-base</artifactId>\n            <version><%= cpswtVersion %></version>\n        </dependency>\n        <dependency>\n            <groupId>org.cpswt</groupId>\n            <artifactId>base-events</artifactId>\n            <version><%= cpswtVersion %></version>\n        </dependency>\n        <dependency>\n            <groupId><%= porticoPOM.groupId %></groupId>\n            <artifactId><%= porticoPOM.artifactId %></artifactId>\n            <version><%= porticoPOM.version %></version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.logging.log4j</groupId>\n            <artifactId>log4j-api</artifactId>\n            <version>2.8.2</version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.logging.log4j</groupId>\n            <artifactId>log4j-core</artifactId>\n            <version>2.8.2</version>\n        </dependency>\n        <dependency>\n            <groupId>com.lmax</groupId>\n            <artifactId>disruptor</artifactId>\n            <version>3.3.6</version>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.7</version>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <repositories>\n        <repository>\n            <id>archiva.internal</id>\n            <name>Internal Release Repository</name>\n            <url><%= releaseUrl %></url>\n        </repository>\n        <repository>\n            <id>archiva.snapshots</id>\n            <name>Internal Snapshot Repository</name>\n            <url><%= snapshotUrl %></url>\n        </repository>\n    </repositories>\n    <distributionManagement>\n        <repository>\n            <id>archiva.internal</id>\n            <name>Internal Release Repository</name>\n            <url><%= releaseUrl %></url>\n        </repository>\n        <snapshotRepository>\n            <id>archiva.snapshots</id>\n            <name>Internal Snapshot Repository</name>\n            <url><%= snapshotUrl %></url>\n        </snapshotRepository>\n    </distributionManagement>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>2.4.3</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <transformers>\n                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n                                <mainClass>${package.name}.${federate.name}</mainClass>\n                                </transformer>\n                            </transformers>\n                            <filters>\n                                <filter>\n                                    <artifact>*:*</artifact>\n                                    <excludes>\n                                        <exclude>META-INF/*.SF</exclude>\n                                        <exclude>META-INF/*.DSA</exclude>\n                                        <exclude>META-INF/*.RSA</exclude>\n                                    </excludes>\n                                </filter>\n                            </filters>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-surefire-plugin</artifactId>\n                <version>2.19.1</version>\n                <configuration>\n                    <forkMode>once</forkMode>\n                    <argLine>-Djava.library.path=${project.basedir}/target/nar/processid-${cpswt.version}-amd64-Linux-gpp-jni/lib/amd64-Linux-gpp/jni/</argLine>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-antrun-plugin</artifactId>\n                <version>1.8</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>run</goal>\n                        </goals>\n                        <configuration>\n                            <tasks>\n                                <copy todir=\"${basedir}/target/conf\" overwrite=\"true\">\n                                    <fileset dir=\"${basedir}/conf\" />\n                                </copy>\n                                <copy todir=\"${basedir}/target\" overwrite=\"true\">\n                                    <fileset file=\"${basedir}/RTI.rid\" />\n                                </copy>\n                            </tasks>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.5.1</version>\n                <configuration>\n                    <source>1.8</source>\n                    <target>1.8</target>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n        <profiles>\n        <profile>\n            <id>${federate.name}</id>\n        </profile>\n        <profile>\n            <id>JavaFed</id>\n            <build>\n                <plugins>\n                    <plugin>\n                        <groupId>org.codehaus.mojo</groupId>\n                        <artifactId>exec-maven-plugin</artifactId>\n                        <version>1.5.0</version>\n                        <goals>\n                            <goal>java</goal>\n                        </goals>\n                        <configuration>\n                            <systemProperties>\n                                <systemProperty>\n                                    <key>java.net.preferIPv4Stack</key>\n                                    <value>true</value>\n                                </systemProperty>\n                            </systemProperties>\n                            <classpathScope>runtime</classpathScope>\n                            <mainClass>${package.name}.${federate.name}</mainClass>\n                            <arguments>\n                                <argument>-configFile</argument>\n                                <argument>${configFile}</argument>\n                            </arguments>\n                        </configuration>\n                    </plugin>\n                </plugins>\n            </build>\n        </profile>\n    </profiles>\n</project>\n",
    "java/federatertifactory.java.ejs": "<% /*federatertifactory( melderpackagename, classname, allinteractiondata, allobjectdata ) ::= <<*/%>\npackage <%= melderpackagename %>;\n\npublic class <%=classname %> {\n\n\t<%/* allinteractiondata:interfacemember() */%>\n\tprivate <%=allinteractiondata.name %>Interface _<%=allinteractiondata.name %>_var;\n\t\n\t<%/*  allobjectdata:interfacemember() */%>\n\tprivate <%=allobjectdata.name %>Interface _<%=allobjectdata.name %>_var;\n\t\n\t<%/*  allinteractiondata:setinterfacemember() */%>\n\tpublic void set_<%= allinteractiondata.name  %>Interface( <%= allinteractiondata.name  %>Interface interface_var ) {\n\t\t_<%= allinteractiondata.name %>_var = interface_var;\n\t}\n\n\t<%/*  allobjectdata:setinterfacemember() */%>\n\tpublic void set_<%= allobjectdata.name  %>Interface( <%= allobjectdata.name  %>Interface interface_var ) {\n\t\t_<%= allobjectdata.name %>_var = interface_var;\n\t}\n\n\t<%/*  allinteractiondata:getinterfacemember() */%>\n\tpublic <%= allinteractiondata.name %>Interface get_<%= allinteractiondata.name %>Interface() {\n\t\treturn _<%= allinteractiondata.name %>_var;\n\t}\n\t\n\t<%/*  allobjectdata:getinterfacemember() */%>\n\tpublic <%= allobjectdata.name %>Interface get_<%= allobjectdata.name %>Interface() {\n\t\treturn _<%= allobjectdata.name %>_var;\n\t}\n}",
    "java/gridlabd-config.json.ejs": "{\n    \"federateName\": \"<%=classname%>\",\n    \"federationId\": \"<%=projectName%>\",\n    \"fomFilepath\": \"conf/<%=classname%>.xml\",\n    \"maxReconnectAttempts\": 12,\n    \"waitReconnectMs\": 5000,\n    \"isLateJoiner\": false,\n    \"stepSize\": <%=step%>,\n    \"lookAhead\": <%=lookahead%>,\n    \"workingDirectory\": \".\",\n    \"modelFilePath\": \"model.glm\"\n}\n",
    "java/gridlabd-run.sh.ejs": "#!/bin/bash\nconfigFile=conf/<%=classname%>.json\nif [ $# -eq 1 ] && [ -f $1 ]; then\n    configFile=$1\nfi\n\necho using the file $configFile\njava -Djava.net.preferIPv4Stack=true -Dlog4j.configurationFile=conf/log4j2.xml -jar <%=jarfile%> $configFile\n\n",
    "java/interfacecommon.java.ejs": "<% /*interfacecommon(isinteraction,classname,parentclassname,hlaclassname,datamembers,alldatamembers) */ %>\n\n/**\n* Returns the handle (RTI assigned) of this instance's <%=isinteraction?\"interaction\":\"object\"%> class .\n* \n* @return the handle (RTI assigned) if this instance's <%=isinteraction?\"interaction\":\"object\"%> class\n*/\npublic int getClassHandle();\n\n/**\n* Returns the fully-qualified (dot-delimited) name of this instance's <%=isinteraction?\"interaction\":\"object\"%> class.\n* \n* @return the fully-qualified (dot-delimited) name of this instance's <%=isinteraction?\"interaction\":\"object\"%> class\n*/\npublic String getClassName();\n\n/**\n* Returns the simple name (last name in its fully-qualified dot-delimited name)\n* of this instance's <%=isinteraction?\"interaction\":\"object\"%> class.\n* \n* @return the simple name of this instance's <%=isinteraction?\"interaction\":\"object\"%> class \n*/\npublic String getSimpleClassName();\n\n/**\n* Returns a set containing the names of all of the non-hidden<%=isinteraction?\"parameter\":\"attribute\"%>s of an\n* <%=isinteraction?\"interaction\":\"object\"%> class instance.\n*\n* @return set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s of an\n* <%=isinteraction?\"interaction\":\"object\"%> class instance\n*/\npublic Set< String > get<%=isinteraction?\"Parameter\":\"Attribute\"%>Names();\n\n/**\n* Returns a set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s of an\n* <%=isinteraction?\"interaction\":\"object\"%> class instance.\n*\n* @return set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s of an\n* <%=isinteraction?\"interaction\":\"object\"%> class instance\n*/\npublic Set< String > getAll<%=isinteraction?\"Parameter\":\"Attribute\"%>Names();\n\n/**\n* Publishes the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of the class for a federate.\n*\n* @param rti handle to the Local RTI Component\n*/\npublic void publish<%=isinteraction?\"Interaction\":\"Object\"%>( RTIambassador rti );\n\n/**\n* Unpublishes the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of this class for a federate.\n*\n* @param rti handle to the Local RTI Component\n*/\npublic void unpublish<%=isinteraction?\"Interaction\":\"Object\"%>( RTIambassador rti );\n\n/**\n* Subscribes a federate to the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of this class.\n*\n* @param rti handle to the Local RTI Component\n*/\npublic void subscribe<%=isinteraction?\"Interaction\":\"Object\"%>( RTIambassador rti );\n\n/**\n* Unsubscribes a federate from the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of this class.\n*\n* @param rti handle to the Local RTI Component\n*/\npublic void unsubscribe<%=isinteraction?\"Interaction\":\"Object\"%>( RTIambassador rti );\n\n<% if(isinteraction){ %><% }else{ %>\n/**\n* Returns a data structure containing the handles of all attributes for this object\n* class that are currently marked for subscription.  To actually subscribe to these\n* attributes, a federate must call <objectclassname>.subscribe( RTIambassador rti ).\n*\n* @return data structure containing the handles of all attributes for this object\n* class that are currently marked for subscription\n*/\npublic AttributeHandleSet getSubscribedAttributeHandleSet();\n<%}%>",
    "java/interfaceroot.java.ejs": "<% /* classrootinterface(isinteraction)*/ %>\npackage org.cpswt.hla;\n\nimport java.util.*;\nimport hla.rti.*;\n\npublic interface <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface\n{\n    public int getUniqueID();\n\n    <%-ejs.render(\n        TEMPLATES[\"java/interfacecommon.java.ejs\"],{\n            isinteraction: isinteraction,\n            classname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\n            parentclassname: \"\",\n            hlaclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\n            datamembers: [],\n            alldatamembers: []\n    })%>\n\n    \n<% if(isinteraction){ %><%}else{%>\n    /**\n    * Requests an attribute update for this object instance from the federate that\n    * has modification rights on these attributes.\n    *\n    * @param rti handle to the Local RTI Component\n    */\n    public void requestUpdate( RTIambassador rti );\n\n    /**\n    * Returns the handle (RTI assigned) the corresponds to this object class\n    * instance.  This handle is the instance's unique identifier to the RTI.\n    *\n    * @return the handle (RTI assigned) of this object class instance.\n    */\n    public int getObjectHandle();\n<%}%>\n\n    /**\n    * Returns the timestamp for this <%=isinteraction?\"interaction\":\"object\"%>.  \"receive order\" <%=isinteraction?\"interaction\":\"object\"%>s\n    * should have a timestamp of -1.\n    *\n    * @return timestamp for this <%=isinteraction?\"interaction\":\"object\"%>\n    */\n    public double getTime();\n    \n    /**\n    * Sets the timestamp of this <%=isinteraction?\"interaction\":\"object\"%> to \"time\".\n    *\n    * @param time new timestamp for this <%=isinteraction?\"interaction\":\"object\"%>\n    */\n    public void setTime( double time );\n\n    /**\n    * Sets the timestamp of this <%=isinteraction?\"interaction\":\"object\"%> to \"logicalTime\".\n    *\n    * @param logicalTime new timestamp for this <%=isinteraction?\"interaction\":\"object\"%>\n    */\n    public void setTime( LogicalTime logicalTime );\n\n    /**\n    * Returns the value of the <%=isinteraction?\"parameter\":\"attribute\"%> named \"datamemberName\" for this\n    * <%=isinteraction?\"interaction\":\"object\"%>.\n    *\n    * @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value to retrieve\n    * @return the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose name is \"datamemberName\"\n    */\n    public Object get<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName );\n\n    /**\n    * Returns the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose handle is \"datamemberHandle\"\n    * (RTI assigned) for this <%=isinteraction?\"interaction\":\"object\"%>.\n    *\n    * @param datamemberHandle handle (RTI assigned) of <%=isinteraction?\"parameter\":\"attribute\"%> whose\n    * value to retrieve\n    * @return the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose handle is \"datamemberHandle\"\n    */\n    public Object get<%=isinteraction?\"Parameter\":\"Attribute\"%>( int datamemberHandle );\n        \n    /**\n    * Set the values of the <%=isinteraction?\"parameter\":\"attribute\"%>s in this <%=isinteraction?\"interaction\":\"object\"%> using\n    * \"datamemberMap\".  \"datamemberMap\" is usually acquired as an argument to\n    * an RTI federate callback method such as \"receiveInteraction\".\n    *\n    * @param datamemberMap  contains new values for the <%=isinteraction?\"parameter\":\"attribute\"%>s of\n    * this <%=isinteraction?\"interaction\":\"object\"%>\n    */\n    public void set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap );\n\n    /**\n    * Sets the value of the <%=isinteraction?\"parameter\":\"attribute\"%> named \"datamemberName\" to \"value\"\n    * in this <%=isinteraction?\"interaction\":\"object\"%>.  \"value\" is converted to data type of \"datamemberName\"\n    * if needed.\n    * This action can also be affected by calling the set_<datamemberName>( value )\n    * method on the <%=isinteraction?\"interaction\":\"object\"%> using a reference to the <%=isinteraction?\"interaction\":\"object\"%>'s actual\n    * class.\n    *\n    * @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value is to be set\n    * to \"value\"\n    * @param value new value of <%=isinteraction?\"parameter\":\"attribute\"%> called \"datamemberName\"\n    */\n    public void set<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName, String value );\n\n    /**\n    * Sets the value of the <%=isinteraction?\"parameter\":\"attribute\"%> named \"datamemberName\" to \"value\"\n    * in this <%=isinteraction?\"interaction\":\"object\"%>.  \"value\" should have the same data type as that of\n    * the \"datamemberName\" <%=isinteraction?\"parameter\":\"attribute\"%>.\n    * This action can also be affected by calling the set_<datamemberName>( value )\n    * method on the <%=isinteraction?\"interaction\":\"object\"%> using a reference to the <%=isinteraction?\"interaction\":\"object\"%>'s actual\n    * class.\n    *\n    * @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value is to be set\n    * to \"value\"\n    * @param value new value of <%=isinteraction?\"parameter\":\"attribute\"%> called \"datamemberName\"\n    */\n    public void set<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName, Object value );\n\n<% if(isinteraction){ %>\n    /**\n    * Sends this interaction to the RTI, with the specified timestamp \"time\".\n    * This method should be used to send interactions that have \"timestamp\"\n    * ordering.\n    *\n    * @param rti handle to the Local RTI Component\n    * @param time timestamp for this interaction.  The timestamp should be no\n    * less than the current federation time + the LOOKAHEAD value of the federate\n    * sending this interaction.\n    */\n    public void sendInteraction( RTIambassador rti, double time ) throws Exception;\n\n    /**\n    * Sends this interaction to the RTI (without a timestamp).\n    * This method should be used to send interactions that have \"receive\"\n    * ordering.\n    *\n    * @param rti handle to the Local RTI Component\n    */\n    public void sendInteraction( RTIambassador rti ) throws Exception ;\n<%}else{%>\n    /**\n    * Registers this object with the RTI.  This method is usually called by a\n    * federate who \"owns\" this object, i.e. the federate that created it and\n    * has write-privileges to its attributes (so, it is responsible for updating\n    * these attribute and conveying their updated values to the RTI).\n    *\n    * @param rti handle to the Local RTI Component\n    */ \n    public void registerObject( RTIambassador rti );\n    \n    /**\n    * Unregisters this object with the RTI.  The RTI will destroy all information\n    * it contains regarding this object as a result.  This method is usually\n    * called by a federate who \"owns\" this object, i.e. the federate that created\n    * it and has write-privileges to its attributes.\n    *\n    * @param rti handle to the Local RTI Component\n    */ \n    public void unregisterObject( RTIambassador rti );\n\n    /**\n    * Broadcasts the attributes of this object and their values to the RTI, where\n    * the values have \"time\" as their timestamp.  This call should be used for\n    * objects whose attributes have \"timestamp\" ordering.\n    *\n    * @param rti handle to the Local RTI Component\n    * @param time timestamp on attribute values of this object\n    * @param force if \"false\", only the attributes whose values have changed since\n    * the last call to \"updateAttributeValues\" will be broadcast to the RTI.  If\n    * \"true\", all attributes and their values are broadcast to the RTI.\n    */\n    public void updateAttributeValues( RTIambassador rti, double time, boolean force );\n\n    /**\n    * Like {@link #updateAttributeValues( RTIambassador rti, double time, boolean force )},\n    * except \"force\" is always false.\n    *\n    * @param rti handle to the Local RTI Component\n    * @param time timestamp on attribute values of this object\n    */\n    public void updateAttributeValues( RTIambassador rti, double time );\n\n    /**\n    * Broadcasts the attributes of this object and their values to the RTI (with\n    * no timestamp).  This call should be used for objects whose attributes have\n    * \"receive\" ordering.\n    *\n    * @param rti handle to the Local RTI Component\n    * @param force if \"false\", only the attributes whose values have changed since\n    * the last call to \"updateAttributeValues\" will be broadcast to the RTI.  If\n    * \"true\", all attributes and their values are broadcast to the RTI.\n    */\n    public void updateAttributeValues( RTIambassador rti, boolean force );\n\n    /**\n    * Like {@link #updateAttributeValues( RTIambassador rti, boolean force )},\n    * except \"force\" is always false.\n    *\n    * @param rti handle to the Local RTI Component\n    */\n    public void updateAttributeValues( RTIambassador rti );    \n<%}%>    \n}",
    "java/java-run.sh.ejs": "#!/bin/bash\nconfigFile=conf/<%=classname%>.json\nif [ $# -eq 1 ] && [ -f $1 ]; then\n    configFile=$1\nfi\n\necho using the file $configFile\njava -Djava.net.preferIPv4Stack=true -Dlog4j.configurationFile=conf/log4j2.xml -jar target/<%=jarfile%> -configFile $configFile\n\n",
    "java/labview-config.json.ejs": "{\n    \"federateName\": \"<%=classname%>\",\n    \"federationId\": \"<%=projectName%>\",\n    \"fomFilepath\": \"conf/<%=classname%>.xml\",\n    \"maxReconnectAttempts\": 12,\n    \"waitReconnectMs\": 5000,\n    \"isLateJoiner\": false,\n    \"stepSize\": <%=step%>,\n    \"lookAhead\": <%=lookahead%>,\n    \"hostAddress\": \"localhost\",\n    \"outgoingPort\": 1234,\n    \"incomingPort\": 9119\n}\n",
    "java/labview-pom.xml.ejs": "<?xml version=\"1.0\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <groupId><%= groupId %></groupId>\n    <version><%= projectVersion %></version>\n    <artifactId>LabView</artifactId>\n    <dependencies>\n        <dependency>\n            <groupId><%= labviewPOM.groupId %></groupId>\n            <artifactId><%= labviewPOM.artifactId %></artifactId>\n            <version><%= labviewPOM.version %></version>\n        </dependency>\n    </dependencies>\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-dependency-plugin</artifactId>\n                <version>3.1.1</version>\n                <executions>\n                    <execution>\n                        <id>copy-dependencies</id>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>copy-dependencies</goal>\n                        </goals>\n                        <configuration>\n                            <outputDirectory>${project.basedir}</outputDirectory>\n                            <overWriteReleases>true</overWriteReleases>\n                            <overWriteSnapshots>true</overWriteSnapshots>\n                            <overWriteIfNewer>true</overWriteIfNewer>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-resources-plugin</artifactId>\n                <version>3.1.0</version>\n                <executions>\n                    <execution>\n                        <id>copy-resources</id>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>copy-resources</goal>\n                        </goals>\n                        <configuration>\n                            <outputDirectory>${basedir}/project</outputDirectory>\n                            <resources>\n                                <resource>\n                                    <directory><%= rootdir %>/ucef-labview/base-project</directory>\n                                </resource>\n                            </resources>\n                            <overwrite>false</overwrite>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n\n",
    "java/labview-run.sh.ejs": "#!/bin/bash\nconfigFile=conf/<%=classname%>.json\nif [ $# -eq 1 ] && [ -f $1 ]; then\n    configFile=$1\nfi\n\necho using the file $configFile\njava -Djava.net.preferIPv4Stack=true -Dlog4j.configurationFile=conf/log4j2.xml -jar <%=jarfile%> $configFile\n",
    "java/log4j2.xml.ejs": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration status=\"WARN\">\n    <Appenders>\n        <Console\n            name=\"Console\"\n            target=\"SYSTEM_OUT\">\n            <PatternLayout pattern =\n                \"%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/>\n        </Console>\n    </Appenders>\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\" />\n        </Root>\n    </Loggers>\n</Configuration>\n",
    "java/mapperfederate.java.ejs": "<% /*group mapperfederate;\n\nmapperfederate(\n    classname,\n\tsimname,\n\tstep_size,\n\tmappingconnsdata,\n\tmappingobjectsdata\n) ::= <<*/ -%>\n\npackage <%=simname%>;\n\nimport java.util.StringTokenizer;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\nimport hla.rti.EventRetractionHandle;\nimport hla.rti.LogicalTime;\nimport hla.rti.ReceivedInteraction;\nimport org.cpswt.hla.*;\n\npublic class <%=classname%> extends <%=classname%>Base {\n\n    private static Pattern pattern = Pattern.compile( \"[^#]\" );\n\n\tpublic <%=classname%>(String federationId, String federateId)\n\t\t\tthrows Exception {\n\t\tsuper(federationId, federateId);\n\t}\n\n    public <%=classname%>( String[] args ) throws Exception {\n        super( args );\n    }\n    \n    private static double STEP_EPSILON = 0.000001;\n    \n    public boolean isMapperFederate() {\n        return true;\n    }\n\n    <% /*mappingconnsdata:mappingconnections()*/ %>\n    <% mappingconnsdata.forEach(function(mappingconnectiondata){ %>\n\t///////////////////////////////////////////////////////////////////////////////////////\n\t//\n\t// For <% if(mappingconnectiondata.isSimpleConn){ %>Simple<% }else{ %>Complex<% } %>MappingConnection (ID: <%=mappingconnectiondata.uniqueId%>) between interactions:\n\t//\n\t//         <%=mappingconnectiondata.lHSInteractionName%> --to--> <%=mappingconnectiondata.rHSInteractionName%>\n\t//\n\t// This <% if(mappingconnectiondata.isSimpleConn){ %>Simple<% }else{ %>Complex<% } %>MappingConnection is located at:\n\t//\n\t//         <%=mappingconnectiondata.parentPath%>\n\t//\n\t///////////////////////////////////////////////////////////////////////////////////////\n\tpublic boolean isGuardConditionMet_<%=mappingconnectiondata.lHSInteractionName%>_to_<%=mappingconnectiondata.rHSInteractionName%>_<%=mappingconnectiondata.uniqueId%>(<%=mappingconnectiondata.lHSInteractionName%> i1) {\n\t\t<%-mappingconnectiondata.guardCondition%>\n\t\t<% if(mappingconnectiondata.guardConditionInvalid){ %>return true;<% } %>\n\t}\n\n\n\tpublic <%=mappingconnectiondata.rHSInteractionName%> map_<%=mappingconnectiondata.lHSInteractionName%>_to_<%=mappingconnectiondata.rHSInteractionName%>_<%=mappingconnectiondata.uniqueId%>(<%=mappingconnectiondata.lHSInteractionName%> i1) {\n\t\t<%=mappingconnectiondata.rHSInteractionName%> o1 = create_<%=mappingconnectiondata.rHSInteractionName%>();\n\t\tInteractionRoot o1IR = (InteractionRoot) o1;\n\t    <% if(mappingconnectiondata.isMappedInteractionANetworkPacket){ %>\n\t\tboolean __NETWORK_PACKET_CORRUPT__ = false;\n\t\tInteractionRoot __I1__ = (InteractionRoot) i1;\n\t\tif(__I1__ instanceof NetworkPacket ) {\n\t    \tint numParams = o1.getParameterNames().size();\n\t    \tString __DATA__ = ((NetworkPacket) __I1__).get_data();\n\t    \tif(numParams > 0) {\n\t\t\t    Matcher matcher = pattern.matcher( __DATA__ );\n\t\t\t    if ( !matcher.find() ) {\n\t    \t\t\t__NETWORK_PACKET_CORRUPT__ = true;\n\t    \t\t\tif(o1IR instanceof NetworkPacket && __DATA__.length() == 0 ) {\n\t\t\t    \t\t__NETWORK_PACKET_CORRUPT__ = false;\n\t\t\t    \t}\n\t    \t\t}\n\t    \t} else {\n\t    \t\tif(__DATA__.length() > 0) {\n\t    \t\t\t__NETWORK_PACKET_CORRUPT__ = true;\n\t    \t\t}\n\t    \t}\n\t\t}\n\t\tif(!__NETWORK_PACKET_CORRUPT__) {\n\t\t    <% if(mappingconnectiondata.isMappingSpecsNotEmpty){ %>\n\t\t\t<%-mappingconnectiondata.mappingSpecs%><%}%>\n\t\t}\n\t\t<% }else{ %>\n\t    <% if(mappingconnectiondata.isMappingSpecsNotEmpty){ %>\n\t\t<%-mappingconnectiondata.mappingSpecs%><%}%>\n\t\t<%}%>\n\n\t\to1.set_originFed(i1.get_originFed());\n\t\to1.set_actualLogicalGenerationTime(i1.get_actualLogicalGenerationTime());\n\n\t\treturn o1;\n\t}\n    <%/*EMPTY*/});%>\n    \n    <% /*mappingobjectsdata:mappingobjects()*/ %>\n    <% mappingobjectsdata.forEach(function(mappingobjectdata){ %><%/*EMPTY*/});%>\n    \n\n\t<% /*execute_method()*/ %>\n\tpublic void execute() throws Exception {\n\t    double currentTime = 0;\n\n\t    AdvanceTimeRequest atr = new AdvanceTimeRequest( currentTime );\n\t    putAdvanceTimeRequest( atr );\n\n\t    readyToPopulate();\n\t    readyToRun();\n\n\t    startAdvanceTimeThread(TIME_ADVANCE_MODE.NEXT_EVENT_REQUEST_AVAILABLE);\n\n\t    while( true ) {\n\t    \tSystem.out.print( \"<%=classname%>: Requesting RTI to proceed to (\" + currentTime + \")...\" );\n\t    \t\n\t        atr.requestSyncStart();\n\t        currentTime = atr.getCurrentTime();\n\n\t        System.out.println( \"granted!\" );\n\n\t        InteractionRoot interactionRoot;\n\n\t        System.out.println(\"Now waiting to receive an interaction...\");\n\t        while(  ( interactionRoot = getNextInteractionNoWait() ) != null ) {\n\t            \t\n\t\t\t\tSystem.out.println( \"<%=classname%>: received interaction: \\\"\" + interactionRoot + \"\\\" at time: \" + getCurrentTime() );\n\n\t\t\t\tboolean interactionMapped = false;\t\t\t\n\t\t\t\t<% /*mappingconnsdata:mappingCheck()*/ %>\n\t\t\t\t<% mappingconnsdata.forEach(function(mappingconnectiondata){%>\n\t\t\t\tif( interactionRoot instanceof <%=mappingconnectiondata.lHSInteractionName%> ) {\n\t\t\t\t\t<%=mappingconnectiondata.lHSInteractionName%> i1 = (<%=mappingconnectiondata.lHSInteractionName%>) interactionRoot;\n\t\t\t\t\t\n\t\t\t\t\t\tif(  !(interactionRoot instanceof NetworkPacket) || \"<%=mappingconnectiondata.rHSInteractionName%>\".equals(((NetworkPacket) interactionRoot).get_packetType())  ) {\n\t\n\t\t\t\t\t\t\tif( isGuardConditionMet_<%=mappingconnectiondata.lHSInteractionName%>_to_<%=mappingconnectiondata.rHSInteractionName%>_<%=mappingconnectiondata.uniqueId%>(i1) ) {\n\t\t\t\t\t\t\t\t<%=mappingconnectiondata.rHSInteractionName%> o1 = map_<%=mappingconnectiondata.lHSInteractionName%>_to_<%=mappingconnectiondata.rHSInteractionName%>_<%=mappingconnectiondata.uniqueId%>(i1);\n\t\t\t\t\t\t\t\tSystem.out.println( \"<%=classname%>: Sending interaction: \" + o1 );\n\t\t\t\t\t\t\t\to1.sendInteraction( getRTI(), getMinTSOTimestamp() );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tinteractionMapped = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t<% if(mappingconnectiondata.areBothEndsOfMappingANetworkPacket){ %>\n\t\t\t\t\t\t// Or, if it is a mapping from an interaction type to itself then only check the guard condition\n\t\t\t\t\t\tif ( interactionRoot instanceof NetworkPacket && \"<%=mappingconnectiondata.lHSInteractionName%>\".equals(\"<%=mappingconnectiondata.rHSInteractionName%>\") ) {\n\t\t\t\t\t\t\tif( isGuardConditionMet_NetworkPacket_to_NetworkPacket_<%=mappingconnectiondata.uniqueId%>(i1) ) {\n\t\t\t\t\t\t\t\tNetworkPacket o1 = map_NetworkPacket_to_NetworkPacket_<%=mappingconnectiondata.uniqueId%>(i1);\n\t\t\t\t\t\t\t\tSystem.out.println( \"<%=classname%>: Sending interaction: \" + o1 );\n\t\t\t\t\t\t\t\to1.sendInteraction( getRTI(), getMinTSOTimestamp() );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tinteractionMapped = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t<% } %>\n\t\t\t\t}<%});%>\n\n\t\t\t\tif( !interactionMapped ) {\n\t          \t\tSystem.out.println( \"<%=classname%>: Received unknown interaction: \" + interactionRoot );\n\t           \t}\n\t        }\n\n\t        currentTime = getCurrentTime() + <%=step_size%> + STEP_EPSILON;\n\t        AdvanceTimeRequest newATR = new AdvanceTimeRequest( currentTime );\n\t        putAdvanceTimeRequest( newATR );\n\t        \n\t        atr.requestSyncEnd();\n\t        atr = newATR;\n\t    }\n\t}\n\n\t<% /*main_method()*/ %>\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t    System.out.println( \"<%=classname%> federate starting\" );\n\t    try {\n\t    \t<%=classname%> mapperFed = new <%=classname%>( args );\n\t        mapperFed.execute();\n\t    } catch ( Exception e ) {\n\t        System.err.println( \"Exception caught: \" + e.getMessage() );\n\t        e.printStackTrace();\n\t    }\n\t}\n\n}\n",
    "java/mvn-install.sh.ejs": "#!/bin/bash\nmvn clean install -U\n",
    "java/rti.rid.ejs": "# ================================\n# Portico RTI Initialization Data\n# ================================\n# This file contains all available configuration options for Portico. \n# Values are initially commented out and are provided shown with their default settings.\n#\n# All options are formatted as name=value pairs, the '#' and '!' characters mark comment lines\n#\n# To make use of this file, put it in the directory that your federate is executed from, or set the\n# RTI_RID_FILE environment variable to point at wherever it is located.\n#\n\n# ===================================\n# 1. General Portico Logging Options\n# ===================================\n# (NOTE) Some sub-components have their own log settings. See the sections relaing to them for\n#        those particular properties.\n\n# (1.1) Portico Log Directory\n#        Specify the directory to put the Portico log-files into. This defaults to \"logs\" and\n#        if a relative path is used, it will be releative to the location of the process that\n#        executed Portico\n#\n# portico.logdir = logs\n\n# (1.2) Portico Log Level\n#        Specify the level that Portico will log at. Valid values are: TRACE, DEBUG, INFO, WARN,\n#        ERROR, FATAL, OFF. The default value is \"WARN\".\n#\n# portico.loglevel = INFO\n\n# (1.3) Print FOM when federate Joins\n#        When a federate joins a federation, Portico can pretty-print the FOM data of that\n#        federation. If this is enabled, the FOM is logged to the INFO level (so make sure you\n#        have logging turned up high enough). By default this is disabled.\n#\n# portico.fom.print = disabled\n\n# (1.4) Logging by Handle/Name\n#        Making sense of log files can be difficult. To help make sense of this data, various bits\n#        of HLA information can be logged by their HLA handle or their name. For example, an HLA\n#        object class can be logged by its handle, or by its name.\n#\n#        Any items specified in logWithHandles are logged using their handles (and vice versa for\n#        logWithNames). The format of these properties is a comma-separated list containing any of\n#        the following identifiers (defaults specified in parentheses):\n#\n#        objectClass       (handle)\n#        attributeClass    (handle)\n#        interactionClass  (handle)\n#        parameterClass    (handle)\n#        objectInstance    (name)\n#        space             (handle)\n#        dimension         (handle)\n#        federate          (name)\n#\n#        (NOTE) You only have to specify the bits you want. If a value isn't specified in either\n#               list, it will assume its default value. If a value is specified in both lists, the\n#               logWithNames takes precedence.\n#\n# portico.logWithHandles=objectClass,attributeClass,interactionClass,parameterClass,space,dimension\n# portico.logWithNames=objectInstance,federate\n\n\n# ================================\n# 2. HLA Related RTI Properties\n# ================================\n# These settings relate to how the RTI works with regard to HLA operations\n\n# (2.1) Management Object Model\n#        This controls whether or not the MOM is enabled. By default it is turned on, but if you\n#        don't want it you can turn it off. Valid values are \"enabled\" and \"disabled\"\n#\n# portico.mom = enabled\n\n# (2.2) Save/Restore Data Files Directory\n#        This specifies the path to the directory where federate save/restore data files are stored.\n#        By default, this is the \"savedata\" directory relative to the directory that the federate\n#        was launched from. Any valid operating system path can be specified, as long as it is\n#        writeable by the operating system user under which the federate is executing\n#\n# portico.saveDirectory = ./savedata\n\n# (2.3) Unsupported Methods Throw Exceptions\n#        Portico does not support all the RTIambassador methods in all interface versions. To alert\n#        users to situations where a method is called that isn't support, Portico will log a warning\n#        and take no action. This is often a non-fatal action, but in some situations it may cause\n#        federates to stall or misbehave. As such, if this value is set to true, an RTIinternalError\n#        will be thrown when an unsupported method is called. By default, this is false.\n#\n# portico.unsupportedExceptions = false\n\n# (2.4) Object Names Negotiated With Federation\n#        When registering an object with a specific name, to ensure that name is unique, the\n#        federate much negotiate with the rest of the federation. This incurs a performance hit.\n#        By default, this negotiation is turned off. If you have problems with conflicting names,\n#        set this property to true. In the default mode (negotiation disabled) the RTI is not\n#        totally standards compliant, and conflicts can occur if federates try to register objects\n#        with the same name at the same time (if the requests are sufficiently spaced out in time,\n#        this problem shouldn't occur).\n#\n# portico.object.negotiateNames = false\n\n# (2.5) Unique Federate Names\n#        By default, Portico, like other RTIs, will ensure that all federates in a federation have\n#        unique names. However, in some situations this is not desirable (like running Portico with\n#        JSAF or VBS2). In this case, you can turn the unique name checking to false. When you do\n#        this, what happens is that when Portico sees a name conflict, rather than throwing an\n#        exception it will change the requested name from \"name\" to \"name (handle)\" thus making it\n#        unique. Default is true, set to false to turn unique name checking off.\n#\n# portico.uniqueFederateNames = true\n\n\n# ================================\n# 3. Advanced Options\n# ================================\n# These really shouldn't be changed unless you really know what you want\n\n# (3.1) Portico Communications Binding\n#        Defines the mechanism used by federates to communicate. Two valid options: jgroups, jvm.\n#\n#        jgroups: Use for LAN/WAN communications (default)\n#            jvm: Use when running many federates in separate threads within a single process.\n#\n# portico.connection = jgroups\n\n# (3.2) LRC Tick Timeout\n#        When a federate calls tick() and there is no work to do, the LRC will wait for a period of\n#        time to allow work to arrive before it returns. This is designed to avoid a busy-looping\n#        situation where people are calling tick in a loop while waiting for some event.\n#\n#        The period of time the LRC will wait is specified by this value (in *MILLISECONDS*).\n#        DEFAULT = 5\n#\n#        (NOTE) This does not apply to the tick(min,max) call (in that case, the LRC will wait\n#               for at most \"min\" seconds for work to arrive).\n#\n# portico.lrc.tt = 5\n\n\n# =========================================\n# 4. JGroups Network Settings\n# =========================================\n# Portico uses the JGroups library for its inter-federate network communication.\n# These settings control various parameters of the network layer and JGroups itself.\n\n# (4.1) JGroups UDP Address and Port\n#        Address and port to use for communication between federates.\n#        DEFAULT: 239.20.9.13:20913\n#\n# portico.jgroups.udp.address = 239.20.9.13\n# portico.jgroups.udp.port = 20913\n\n\n# (4.2) JGroups Bind Address\n#        The address/NIC Portico should use. Can use an IP address associated with a NIC, or\n#        one of the following special values:\n#\n#            GLOBAL: Pick a global IP address if available. If not, falls back to a SITE_LOCAL IP address.\n#        SITE_LOCAL: Picks a site local (non routable) IP address, e.g. from the 192.168.0.0 or 10.0.0.0 address range.\n#        LINK_LOCAL: Picks a link-local IP address, from 169.254.1.0 through 169.254.254.255.\n#      NON_LOOPBACK: Picks any non loopback address.\n#          LOOPBACK: Pick a loopback address, e.g. 127.0.0.1.\n#   match-interface: Pick an address which matches a pattern against the interface name, e.g. match-interface:eth.*\n#     match-address: Pick an address which matches a pattern against the host address, e.g. match-address:192.168.*\n#        match-host: Pick an address which matches a pattern against the host name, e.g. match-host:linux.*\n#\n#        DEFAULT: SITE_LOCAL\n#\nportico.jgroups.udp.bindAddress = <%= bindAddress%>\n\n# (4.3) JGroups UDP Sent/Receive Buffer Size\n#        Incoming/Outgoing buffer sizes. Default receive buffer is quite large to allow ample\n#        space on fast networks and avoid dropped packets.\n#\n# portico.jgroups.udp.receiveBuffer = 25M\n# portico.jgroups.udp.sendBuffer = 640K\n\n\n# (4.4) JGroups Bundling Support\n#         If you are sending lots of smaller messages, higher overall throughput can be obtained by\n#         bundling them together into a fewer number of larger messages. However, doing so comes at\n#         the cost of latency. Messages are buffered until either the timeout period (milliseconds)\n#         is reached, or the total size of the messages exceeds the specified threshold. Bundling\n#         is enabled by default. For latency-critical tasks, disable it or reduce the max-timeout.\n#\n# portico.jgroups.bundling = true\n# portico.jgroups.bundling.maxSize = 64K\n# portico.jgroups.bundling.maxTime = 30\n\n\n# (4.5) JGroups Flow Control\n#         Flow control is used to rate limit transmission so that slow receivers don't get overrun,\n#         causing them to drop messages and requiring expensive retransmission.\n#\n#         This value sets the maximum number of bytes that can be sent by a federate before it\n#         needs to receive more credits from other cluster members. These credits are not sent\n#         until the other federates have processed enough of the prior sent messages. The ratio\n#         setting defines how far through its current credits a sender can get before it should\n#         issue a request for more.\n#\n#         Setting the credit limit higher will allow a federate to send more messages before it\n#         gets blocked. Consider adjusting this value in conjunction with the buffer sizes, as\n#         they will dictate storage capacity on the sender side.\n#\n#         Note: If you start experiencing unstable behaviour, turn this value down. Flow control\n#               can be sensitive to the number of messages you try to send out in a hurry. If\n#               bundling is enabled, you can use a higher value because although you are sending\n#               more messages, the actual number hitting the network is smaller.\n#\n# portico.jgroups.flow.credits = 2M\n# portico.jgroups.flow.threshold = 0.4\n\n\n# (4.6) Packet Fragmentation Size\n#         Messages larger than this size will be broken down into smaller ones for transmission,\n#         reducing potentially lengthy delays retransmitting whole large messages when a single\n#         datagram is lost.\n#         Note: The max bundling size must be greater than this value.\n#\n# portico.jgroups.frag.size = 60K\n\n\n# (4.7) JGroups Traffic Auditing\n#         If this option is enabled a special log file will be produced for each federate listing\n#         the messages it has sent and received, along with their size and other useful details.\n#         This information can be used to make judgements about network config (such as bundling\n#         limits) or to just see what is happening in the federation at a network level.\n#\n#         The audit files are placed in the logs directory (see sec 1.1) with the name:\n#         \"audit-FEDERATENAME.log\"\n#\n#         If the auditor is enabled you can specify a detail level to control what is logged.\n#         When set to \"full\", each message will be logged with its specific details. (default)\n#         When set to \"summary\", only the summary tables will be printed\n#\n# portico.jgroups.auditor.enabled = false\n# portico.jgroups.auditor.details = full\n\n# (4.8) JGroups Traffic Audit Filtering\n#         Federates can generate a lot of messages. Sometimes you really just want to zero in\n#         on a particular type of message, or messages for a particular FOM type. These filters\n#         let you do that. These filters work in combination. For example, consider the following:\n#             - action  = sent\n#             - type    = UpdateAttributes\n#             - fomtype = Lifeform, GroundVehicle\n#\n#         Given this, only attribute updates for the FOM classes \"Lifeform\" and \"GroundVehicle\"\n#         that the local federate sends will be logged. Leaving a value empty, or using the\n#         keyword \"all\" will cause no filtering for that type to be applied.\n#\n#         NOTE: If the detail level is set to \"summary\", -no- individual messages will be logged,\n#               regardless of the filter settings.\n#         \n# portico.jgroups.auditor.filter.direction = \n# portico.jgroups.auditor.filter.message   = \n# portico.jgroups.auditor.filter.fomtype   = \n\n# =========================================\n# 5. WAN Connection Options\n# =========================================\n\n# (5.1) WAN Mode Enable/Disable\n#       If true, WAN mode will be enabled and this federate will act as both a\n#       local participant, and also as a bridge for all the local federates.\n#       Messages exchanged on the local JGroups channel will be forwarded to a\n#       central router (see 5.2) to be reflected out to other sites. Messagest\n#       received from the router will be pushed out to the local JGroups channel\n#       so everyone here can process them.\n#\n#       Note that this mode does not support bundling. If enabled in the RID, it\n#       will be active on the local JGroups network, but ignored for the WAN.\n#\n#       Note: Router must be running before federate startup. If not - federates\n#             will fail to start.\n#\n#       Default: false\n#       \n# portico.wan.enabled = false\n\n# (5.2) Router Address/Port\n#       Specifies the address and port of the WAN router to use. Note that the\n#       syntax is \"address:port\".\n#\n#       Default: 127.0.0.1:23114\n#\n# portico.wan.router = 127.0.0.1:23114\n\n# (5.2) Enable / Disable Bundling\n#       Bundling enables higher throughput by grouping together a number of\n#       smaller messages and sending them as one. This makes much more efficient\n#       use of the network and provides considerable improvements to throughput\n#       at a minor cost to latency.\n#\n#       If enabled, the subsequent options will control how it is applied.\n#\n#       Default: true\n#\n# portico.wan.bundle.enabled = true\n\n# (5.3) Max Bundle Size\n#       Messages sent over the WAN will be grouped into bundles and sents as\n#       a batch when their total size exceeds this value. Specify a size with\n#       a suffix of 'b', 'k' or 'm' (or 'g' if you dare!)\n#\n#       Default: 64k\n#\n# portico.wan.bundle.maxsize = 64K\n\n# (5.4) Max Bundle Timeout\n#       The maximum amount of time we will hold messages in the bundler for while\n#       waiting for more messages to arrive and bundle together. From the time that\n#       a message is received, the bundler will hold it for no longer than this\n#       value (specified in milliseconds).\n#\n#       Default: 20\n#\n# portico.wan.bundle.timeout = 20\n\n\n# =========================================\n# A51. Undocumented Settings\n# =========================================\n# This section is a catch-all of settings we use for internal work, and infrequently.\n# Their specific usecase and function is undocumented as they are not intended for general use.\n# portico.container.loglevel = OFF\n# portico.jgroups.loglevel = OFF\n# portico.jgroups.timeout = 1000\n"
}});